/**
 * Contains the main B+ tree implementation template class btree.
 */

/*
 * STX B+ Tree Template Classes v0.9
 * Copyright (C) 2008-2013 Timo Bingmann <tb@panthema.net>
 * Copyright (c) 2014 Stanford University
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef _STR_BTREE_H_
#define _STR_BTREE_H_

// *** Required Headers from the STL

#include <algorithm>
#include <functional>
#include <istream>
#include <ostream>
#include <memory>
#include <cstddef>
#include <assert.h>

#include "Buffer.h"
#include "Object.h"
#include "ObjectManager.h"

// *** Debugging Macros

#ifdef BTREE_DEBUG

#include <iostream>

/// Print out debug information to std::cout if BTREE_DEBUG is defined.
#define BTREE_PRINT(x)          do { if (debug) (std::cout << x << std::endl); } while(0)

/// Assertion only if BTREE_DEBUG is defined. This is not used in verify().
#define BTREE_ASSERT(x)         do { assert(x); } while(0)

#else

/// Print out debug information to std::cout if BTREE_DEBUG is defined.
#define BTREE_PRINT(x)          do { } while(0)

/// Assertion only if BTREE_DEBUG is defined. This is not used in verify().
#define BTREE_ASSERT(x)         do { } while(0)

#endif

/// The maximum of a and b. Used in some compile-time formulas.
#define BTREE_MAX(a,b)          ((a) < (b) ? (b) : (a))

#ifndef BTREE_FRIENDS
/// The macro BTREE_FRIENDS can be used by outside class to access the B+
/// tree internals. This was added for wxBTreeDemo to be able to draw the
/// tree.
#define BTREE_FRIENDS           friend class btree_friend;
#endif

// Disable Third Party warnings
#pragma GCC system_header

namespace RAMCloud {

#define INVALID_NODEID (1)
#define ROOT_ID 100

// primary key for RamCloud objects representing B+ tree nodes.
typedef uint64_t NodeId;

// Encapsulates information about a tree node that helps in exchanging
// information about nodes across functions
struct NodeObjectInfo
{
    Buffer buffer;          // buffer to hold the contents of this node object
    NodeId nodeId;          // primary key for this object
    void* data;             // pointer to a contiguous copy of this object.
                            // if NULL, one can always read the object again
};

/// STR - Some Template Extensions namespace
namespace str {

/** Generates default traits for a B+ tree used as a set. It estimates leaf and
 * inner node sizes by assuming a cache line size of 256 bytes. */
template <typename _Key>
struct btree_default_set_traits
{
    /// If true, the tree will self verify it's invariants after each insert()
    /// or erase(). The header must have been compiled with BTREE_DEBUG defined.
    static const bool   selfverify = false;

    /// If true, the tree will print out debug information and a tree dump
    /// during insert() or erase() operation. The header must have been
    /// compiled with BTREE_DEBUG defined and key_type must be std::ostream
    /// printable.
    static const bool   debug = false;

    /// Number of slots in each leaf of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int    leafslots = BTREE_MAX( 8, 256 / (sizeof(_Key)) );

    /// Number of slots in each inner node of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int    innerslots = BTREE_MAX( 8, 256 / (sizeof(_Key) + sizeof(void*)) );

    /// As of stx-btree-0.9, the code does linear search in find_lower() and
    /// find_upper() instead of binary_search, unless the node size is larger
    /// than this threshold. See notes at
    /// http://panthema.net/2013/0504-STX-B+Tree-Binary-vs-Linear-Search
    static const size_t binsearch_threshold = 256;

    virtual ~btree_default_set_traits()
    {}
};

/** Generates default traits for a B+ tree used as a map. It estimates leaf and
 * inner node sizes by assuming a cache line size of 256 bytes. */
template <typename _Key, typename _Data>
struct btree_default_map_traits
{
    /// If true, the tree will self verify it's invariants after each insert()
    /// or erase(). The header must have been compiled with BTREE_DEBUG defined.
    static const bool   selfverify = false;

    /// If true, the tree will print out debug information and a tree dump
    /// during insert() or erase() operation. The header must have been
    /// compiled with BTREE_DEBUG defined and key_type must be std::ostream
    /// printable.
    static const bool   debug = false;

    /// Number of slots in each leaf of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int    leafslots = BTREE_MAX( 8, 256 / (sizeof(_Key) + sizeof(_Data)) );

    /// Number of slots in each inner node of the tree. Estimated so that each node
    /// has a size of about 256 bytes.
    static const int    innerslots = BTREE_MAX( 8, 256 / (sizeof(_Key) + sizeof(void*)) );

    /// As of stx-btree-0.9, the code does linear search in find_lower() and
    /// find_upper() instead of binary_search, unless the node size is larger
    /// than this threshold. See notes at
    /// http://panthema.net/2013/0504-STX-B+Tree-Binary-vs-Linear-Search
    static const size_t binsearch_threshold = 256;
};

/** @brief Basic class implementing a base B+ tree data structure in memory.
 *
 * The base implementation of a memory B+ tree. It is based on the
 * implementation in Cormen's Introduction into Algorithms, Jan Jannink's paper
 * and other algorithm resources. Almost all STL-required function calls are
 * implemented. The asymptotic time requirements of the STL are not always
 * fulfilled in theory, however in practice this B+ tree performs better than a
 * red-black tree by using more memory. The insertion function splits the nodes
 * on the recursion unroll. Erase is largely based on Jannink's ideas.
 *
 * This class is specialized into btree_set, btree_multiset, btree_map and
 * btree_multimap using default template parameters and facade functions.
 */
template <typename _Key, typename _Data,
          typename _Value = std::pair<_Key, _Data>,
          typename _Compare = std::less<_Key>,
          typename _Traits = btree_default_map_traits<_Key, _Data>,
          bool _Duplicates = false,
          typename _Alloc = std::allocator<_Value>,
          bool _UsedAsSet = false >
class btree
{
public:
    // *** Template Parameter Types

    /// First template parameter: The key type of the B+ tree. This is stored
    /// in inner nodes and leaves
    typedef _Key                        key_type;

    /// Second template parameter: The data type associated with each
    /// key. Stored in the B+ tree's leaves
    typedef _Data                       data_type;

    /// Third template parameter: Composition pair of key and data types, this
    /// is required by the STL standard. The B+ tree does not store key and
    /// data together. If value_type == key_type then the B+ tree implements a
    /// set.
    typedef _Value                      value_type;

    /// Fourth template parameter: Key comparison function object
    typedef _Compare                    key_compare;

    /// Fifth template parameter: Traits object used to define more parameters
    /// of the B+ tree
    typedef _Traits                     traits;

    /// Sixth template parameter: Allow duplicate keys in the B+ tree. Used to
    /// implement multiset and multimap.
    static const bool                   allow_duplicates = _Duplicates;

    /// Seventh template parameter: STL allocator for tree nodes
    typedef _Alloc                      allocator_type;

    /// Eighth template parameter: boolean indicator whether the btree is used
    /// as a set. In this case all operations on the data arrays are
    /// omitted. This flag is kind of hacky, but required because
    /// sizeof(empty_struct) = 1 due to the C standard. Without the flag, lots
    /// of superfluous copying would occur.
    static const bool                   used_as_set = _UsedAsSet;

    // The macro BTREE_FRIENDS can be used by outside class to access the B+
    // tree internals. This was added for wxBTreeDemo to be able to draw the
    // tree.
    BTREE_FRIENDS

public:
    // *** Constructed Types

    /// Typedef of our own type
    typedef btree<key_type, data_type, value_type, key_compare,
                  traits, allow_duplicates, allocator_type, used_as_set> btree_self;

    /// Size type used to count keys
    typedef size_t                              size_type;

    /// The pair of key_type and data_type, this may be different from value_type.
    typedef std::pair<key_type, data_type>      pair_type;

public:
    // *** Static Constant Options and Values of the B+ Tree

    /// Base B+ tree parameter: The number of key/data slots in each leaf
    static const unsigned short         leafslotmax =  traits::leafslots;

    /// Base B+ tree parameter: The number of key slots in each inner node,
    /// this can differ from slots in each leaf.
    static const unsigned short         innerslotmax =  traits::innerslots;

    /// Computed B+ tree parameter: The minimum number of key/data slots used
    /// in a leaf. If fewer slots are used, the leaf will be merged or slots
    /// shifted from it's siblings.
    static const unsigned short minleafslots = (leafslotmax / 2);

    /// Computed B+ tree parameter: The minimum number of key slots used
    /// in an inner node. If fewer slots are used, the inner node will be
    /// merged or slots shifted from it's siblings.
    static const unsigned short mininnerslots = (innerslotmax / 2);

    /// Debug parameter: Enables expensive and thorough checking of the B+ tree
    /// invariants after each insert/erase operation.
    static const bool                   selfverify = traits::selfverify;

    /// Debug parameter: Prints out lots of debug information about how the
    /// algorithms change the tree. Requires the header file to be compiled
    /// with BTREE_DEBUG and the key type must be std::ostream printable.
    static const bool                   debug = traits::debug;

private:
    // *** Node Classes for In-Memory Nodes

    /// The header structure of each node in-memory. This structure is extended
    /// by inner_node or leaf_node.
    struct node
    {
        /// Level in the b-tree, if level == 0 -> leaf node
        unsigned short  level;

        /// Number of key slotuse use, so number of valid children or data
        /// pointers
        unsigned short  slotuse;

        /// Delayed initialisation of constructed node
        inline void initialize(const unsigned short l)
        {
            level = l;
            slotuse = 0;
        }

        /// True if this is a leaf node
        inline bool isleafnode() const
        {
            return (level == 0);
        }
    };

    /// Extended structure of a inner node in-memory. Contains only keys and no
    /// data items.
    struct inner_node : public node
    {
        /// Define an related allocator for the inner_node structs.
        typedef typename _Alloc::template rebind<inner_node>::other alloc_type;

        /// Keys of children or data pointers
        key_type        slotkey[innerslotmax];

        /// Pointers to children
        NodeId          childid[innerslotmax+1];

        /// Set variables to initial values
        inline void initialize(const unsigned short l)
        {
            node::initialize(l);
        }

        /// True if the node's slots are full
        inline bool isfull() const
        {
            return (node::slotuse == innerslotmax);
        }

        /// True if few used entries, less than half full
        inline bool isfew() const
        {
            return (node::slotuse <= mininnerslots);
        }

        /// True if node has too few entries
        inline bool isunderflow() const
        {
            return (node::slotuse < mininnerslots);
        }
    };

    /// Extended structure of a leaf node in memory. Contains pairs of keys and
    /// data items. Key and data slots are kept in separate arrays, because the
    /// key array is traversed very often compared to accessing the data items.
    struct leaf_node : public node
    {
        /// Define an related allocator for the leaf_node structs.
        typedef typename _Alloc::template rebind<leaf_node>::other alloc_type;

        /// Double linked list pointers to traverse the leaves
        NodeId          prevleaf;

        /// Double linked list pointers to traverse the leaves
        NodeId          nextleaf;

        /// Keys of children or data pointers
        key_type        slotkey[leafslotmax];

        /// Array of data
        data_type       slotdata[used_as_set ? 1 : leafslotmax];

        /// Set variables to initial values
        inline void initialize()
        {
            node::initialize(0);
            prevleaf = nextleaf = INVALID_NODEID;
        }

        /// True if the node's slots are full
        inline bool isfull() const
        {
            return (node::slotuse == leafslotmax);
        }

        /// True if few used entries, less than half full
        inline bool isfew() const
        {
            return (node::slotuse <= minleafslots);
        }

        /// True if node has too few entries
        inline bool isunderflow() const
        {
            return (node::slotuse < minleafslots);
        }
    };

private:
    // *** Template Magic to Convert a pair or key/data types to a value_type

    /// For sets the second pair_type is an empty struct, so the value_type
    /// should only be the first.
    template <typename value_type, typename pair_type>
    struct btree_pair_to_value
    {
        /// Convert a fake pair type to just the first component
        inline value_type operator()(pair_type& p) const {
            return p.first;
        }
        /// Convert a fake pair type to just the first component
        inline value_type operator()(const pair_type p) const {
            return p.first;
        }
    };

    /// For maps value_type is the same as the pair_type
    template <typename value_type>
    struct btree_pair_to_value<value_type, value_type>
    {
        /// Identity "convert" a real pair type to just the first component
        inline value_type operator()(pair_type p) const {
            return p;
        }
    };

    /// Using template specialization select the correct converter used by the
    /// iterators
    typedef btree_pair_to_value<value_type, pair_type> pair_to_value_type;

public:
    // *** Iterators and Reverse Iterators

    class iterator;

    /// STL-like iterator object for B+ tree items. The iterator points to a
    /// specific slot number in a leaf.
    class iterator
    {
    public:
        // *** Types

        /// The key type of the btree. Returned by key().
        typedef typename btree::key_type                key_type;

        /// The data type of the btree. Returned by data().
        typedef typename btree::data_type               data_type;

        /// The value type of the btree. Returned by operator*().
        typedef typename btree::value_type              value_type;

        /// The pair type of the btree.
        typedef typename btree::pair_type               pair_type;

        /// Reference to the value_type. STL required.
        typedef value_type&             reference;

        /// Pointer to the value_type. STL required.
        typedef value_type*             pointer;

        /// STL-magic iterator category
        typedef std::bidirectional_iterator_tag iterator_category;

        /// STL-magic
        typedef ptrdiff_t               difference_type;

        /// Our own type
        typedef iterator                self;

    private:
        // *** Members

        /// Reference to the btree that this iterator corresponds to
        btree_self*             parentBtree;

        /// The nodeId of the currentl referenced leaf node in the tree
        NodeId                  currentNodeId;

        /// Current key/data slot referenced
        unsigned short          currslot;

        /// Buffer to hold the contents of the currently referenced leaf
        Buffer                  buffer;

        /// Pointer to a contiguous copy of the currently referenced leaf node
        const leaf_node*        currnode;

        /// Also friendly to the base btree class, because erase_iter() needs
        /// to read the currnode and currslot values directly.
        friend class btree<key_type, data_type, value_type, key_compare,
                           traits, allow_duplicates, allocator_type, used_as_set>;

        /// Evil! A temporary value_type to STL-correctly deliver operator* and
        /// operator->
        mutable value_type              temp_value;

        // The macro BTREE_FRIENDS can be used by outside class to access the B+
        // tree internals. This was added for wxBTreeDemo to be able to draw the
        // tree.
        BTREE_FRIENDS

    public:
        // *** Methods
        /// Default-Constructor of a mutable iterator
        inline iterator(btree_self* tree = NULL)
            : parentBtree(tree), currentNodeId(INVALID_NODEID), currslot(0),
              buffer(), currnode(NULL)
        { }

        /// Initializing-Constructor of a mutable iterator
        inline iterator(btree_self *tree, NodeId nodeId, unsigned short s)
            : parentBtree(tree), currentNodeId(nodeId), currslot(s),
              buffer(), currnode(NULL)
        { }

        inline iterator(const iterator &it)
            : parentBtree(it.parentBtree),
              currentNodeId(it.currentNodeId),
              currslot(it.currslot),
              buffer(), currnode(NULL)
        { }

        /// Implement the = operator to avoid invocation of the operator=
        /// method on the Buffer class which does not exist
        inline iterator& operator=(const iterator &it)
        {
            parentBtree = it.parentBtree;
            currentNodeId = it.currentNodeId;
            currslot = it.currslot;
            buffer.reset();
            currnode = NULL;
            return *this;
        }

        /// Releases memory allocated in the buffer
        inline ~iterator()
        {
        }

        /// Dereference the iterator, this is not a value_type& because key and
        /// value are not stored together
        inline reference operator*()
        {
            temp_value = pair_to_value_type()( pair_type(key(),data()) );
            return temp_value;
        }

        /// Dereference the iterator. Do not use this if possible, use key()
        /// and data() instead. The B+ tree does not stored key and data
        /// together.
        inline pointer operator->()
        {
            temp_value = pair_to_value_type()( pair_type(key(),data()) );
            return &temp_value;
        }

        /// Key of the current slot
        inline const key_type& key()
        {
            // If currnode is not NULL, then don't read from the log
            // unnecessarily. Instead, use what has already been read.
            // This assumes that, every time the iterator advances to
            // a new node, currnode is reset to NULL
            if (!currnode)
                currnode = static_cast<const leaf_node *>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));

            return currnode->slotkey[currslot];
        }

        /// Read-only reference to the current data object
        inline const data_type& data()
        {
            // If currnode is not NULL, then don't read from the log
            // unnecessarily. Instead, use what has already been read.
            // This assumes that, every time the iterator advances to
            // a new node, currnode is reset to NULL
            if (!currnode)
                currnode = static_cast<const leaf_node *>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));

            return currnode->slotdata[used_as_set ? 0 : currslot];
        }

        /// Prefix++ advance the iterator to the next slot
        inline self& operator++()
        {
            if (!currnode)
                currnode = static_cast<const leaf_node*>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));


            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != INVALID_NODEID) {
                currentNodeId = currnode->nextleaf;
                currslot = 0;
                currnode = NULL;
                buffer.reset();
            }
            else {
                // this is end()
                currentNodeId = INVALID_NODEID;
                currslot = 0;
                buffer.reset();
                currnode = NULL; 
            }

            return *this;
        }

        /// Postfix++ advance the iterator to the next slot
        inline self operator++(int)
        {
            self tmp = *this;   // copy ourselves

            if (!currnode)
                currnode = static_cast<const leaf_node*>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));

            if (currslot + 1 < currnode->slotuse) {
                ++currslot;
            }
            else if (currnode->nextleaf != INVALID_NODEID) {
                currentNodeId = currnode->nextleaf;
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }
            else {
                // this is end()
                currentNodeId = INVALID_NODEID;
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return tmp;
        }

        /// Prefix-- backstep the iterator to the last slot
        inline self& operator--()
        {
            if (!currnode)
                currnode = static_cast<const leaf_node*>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));

            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != INVALID_NODEID) {
                currentNodeId = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
                buffer.reset();
                currnode = NULL;
            }
            else {
                // this is begin()
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return *this;

        }

        /// Postfix-- backstep the iterator to the last slot
        inline self operator--(int)
        {
            self tmp = *this;   // copy ourselves

            if (!currnode)
                currnode = static_cast<const leaf_node*>(
                                    parentBtree->getPointerToObject(currentNodeId, &buffer));

            if (currslot > 0) {
                --currslot;
            }
            else if (currnode->prevleaf != INVALID_NODEID) {
                currnode = currnode->prevleaf;
                currslot = currnode->slotuse - 1;
                buffer.reset();
                currnode = NULL;
            }
            else {
                // this is begin()
                currslot = 0;
                buffer.reset();
                currnode = NULL;
            }

            return tmp;
        }

        /// Equality of iterators
        inline bool operator==(const self& x) const
        {
            return (x.currentNodeId == currentNodeId) && (x.currslot == currslot);
        }

        /// Inequality of iterators
        inline bool operator!=(const self& x) const
        {
            return (x.currentNodeId != currentNodeId) || (x.currslot != currslot);
        }
    };

public:
    // *** Small Statistics Structure

    /** A small struct containing basic statistics about the B+ tree. It can be
     * fetched using get_stats(). */
    struct tree_stats
    {
        /// Number of items in the B+ tree
        size_type       itemcount;

        /// Number of leaves in the B+ tree
        size_type       leaves;

        /// Number of inner nodes in the B+ tree
        size_type       innernodes;

        /// Base B+ tree parameter: The number of key/data slots in each leaf
        static const unsigned short     leafslots = btree_self::leafslotmax;

        /// Base B+ tree parameter: The number of key slots in each inner node.
        static const unsigned short     innerslots = btree_self::innerslotmax;

        /// Zero initialized
        inline tree_stats()
            : itemcount(0),
              leaves(0), innernodes(0)
        {
        }

        /// Return the total number of nodes
        inline size_type nodes() const
        {
            return innernodes + leaves;
        }

        /// Return the average fill of leaves
        inline double avgfill_leaves() const
        {
            return static_cast<double>(itemcount) / (leaves * leafslots);
        }
    };

private:
    // *** Tree Object Data Members

    /// NodeId of the first leaf in the doubly linked list chain
    NodeId m_headleafId;

    /// Other small statistics about the B+ tree
    tree_stats  m_stats;

    /// Key comparison object. More comparison functions are generated from
    /// this < relation.
    key_compare m_key_less;

    /// Memory allocator.
    allocator_type m_allocator;

    /// tableId of the RAMCloud table that this logical tree corresponds to
    uint64_t treeTableId;

    /// Pointer to the objectManager instance that corresponds to a specific
    /// MasterService
    ObjectManager* objMgr;

    /// this acts as the primary key for the objects representing the nodes
    /// of the tree. In particular, it represents the next nodeId that can
    /// be used to create a new node/RamCloud object
    uint64_t nextNodeId;

    /// NodeId corresponding to the root of the tree. This corresponds to the
    /// primary key of the RamCloud object storing the root of the tree.
    NodeId m_rootId;

    /// Global buffer that contains all the log records including necessary
    /// tombstones pertaining to the current insertion/deletion operation.
    /// At the end of the operation, this buffer is merely copied to the log.
    Buffer logBuffer;

    /// Number of log entries in the logBuffer. This is useful when atomically
    /// flushing the buffer to the log.
    uint32_t numEntries;

    /// Map between nodeId and offset in #logBuffer. This is useful when the
    /// parent needs to occassionally read its child before its child has been
    /// written to the log. Since, the object would have only been written to
    /// #logBuffer, we need to know the offset in it. This is currently only
    /// used during an erase sequence
    std::map<NodeId, uint32_t> cache;

public:
    // *** Constructors and Destructor

    /// Default constructor initializing an empty B+ tree with the standard key
    /// comparison function
    explicit inline btree(uint64_t tableId, ObjectManager *objMgr,
                          const allocator_type &alloc = allocator_type())
        : m_headleafId(INVALID_NODEID), m_allocator(alloc),
          treeTableId(tableId), objMgr(objMgr), nextNodeId(ROOT_ID),
          m_rootId(ROOT_ID), logBuffer(), numEntries(0), cache()
    {
    }

    /// Default constructor recovering an existing B+ tree with the standard key
    /// comparison function
    explicit inline btree(uint64_t tableId, ObjectManager *objMgr,
                          uint64_t highestUsedId,
                          const allocator_type &alloc = allocator_type())
    : m_headleafId(INVALID_NODEID), m_allocator(alloc),
      treeTableId(tableId), objMgr(objMgr), nextNodeId(highestUsedId + 1),
      m_rootId(ROOT_ID), logBuffer(), numEntries(0), cache()
    {
    }

    /// Constructor initializing an empty B+ tree with a special key
    /// comparison object
    explicit inline btree(uint64_t tableId, ObjectManager* objMgr,
                          const key_compare &kcf,
                          const allocator_type &alloc = allocator_type())
        : m_headleafId(INVALID_NODEID),
          m_key_less(kcf), m_allocator(alloc),
          treeTableId(tableId), objMgr(objMgr), nextNodeId(ROOT_ID), m_rootId(ROOT_ID),
          logBuffer(), numEntries(0), cache()
    {
    }

    /// Constructor initializing a B+ tree with the range [first,last). The
    /// range need not be sorted.
    template <class InputIterator>
    inline btree(uint64_t tableId, ObjectManager* objMgr,
                 InputIterator first, InputIterator last,
                 const allocator_type &alloc = allocator_type())
        : m_headleafId(INVALID_NODEID), m_allocator(alloc),
          treeTableId(tableId), objMgr(objMgr), nextNodeId(ROOT_ID), m_rootId(ROOT_ID),
          logBuffer(), numEntries(0), cache()
    {
        insert(first, last);
    }

    /// Constructor initializing a B+ tree with the range [first,last) and a
    /// special key comparison object.
    template <class InputIterator>
    inline btree(uint64_t tableId, ObjectManager* objMgr,
                 InputIterator first, InputIterator last,
                 const key_compare &kcf,
                 const allocator_type &alloc = allocator_type())
        : m_headleafId(INVALID_NODEID),
          m_key_less(kcf), m_allocator(alloc),
          treeTableId(tableId), objMgr(objMgr), nextNodeId(ROOT_ID), m_rootId(ROOT_ID),
          logBuffer(), numEntries(0), cache()
    {
        insert(first, last);
    }

    /// Frees up all used B+ tree memory pages
    inline ~btree()
    {
        clear();
    }

public:
    // *** Key and Value Comparison Function Objects

    /// Function class to compare value_type objects. Required by the STL
    class value_compare
    {
    protected:
        /// Key comparison function from the template parameter
        key_compare     key_comp;

        /// Constructor called from btree::value_comp()
        inline value_compare(key_compare kc)
            : key_comp(kc)
        { }

        /// Friendly to the btree class so it may call the constructor
        friend class btree<key_type, data_type, value_type, key_compare,
                           traits, allow_duplicates, allocator_type, used_as_set>;

    public:
        /// Function call "less"-operator resulting in true if x < y.
        inline bool operator()(const value_type& x, const value_type& y) const
        {
            return key_comp(x.first, y.first);
        }
    };

    /// Constant access to the key comparison object sorting the B+ tree
    inline key_compare key_comp() const
    {
        return m_key_less;
    }

    /// Constant access to a constructed value_type comparison object. Required
    /// by the STL
    inline value_compare value_comp() const
    {
        return value_compare(m_key_less);
    }

private:
    // *** Convenient Key Comparison Functions Generated From key_less

    /// True if a < b ? "constructed" from m_key_less()
    inline bool key_less(const key_type &a, const key_type b) const
    {
        return m_key_less(a, b);
    }

    /// True if a <= b ? constructed from key_less()
    inline bool key_lessequal(const key_type &a, const key_type b) const
    {
        return !m_key_less(b, a);
    }

    /// True if a > b ? constructed from key_less()
    inline bool key_greater(const key_type &a, const key_type &b) const
    {
        return m_key_less(b, a);
    }

    /// True if a >= b ? constructed from key_less()
    inline bool key_greaterequal(const key_type &a, const key_type b) const
    {
        return !m_key_less(a, b);
    }

    /// True if a == b ? constructed from key_less(). This requires the <
    /// relation to be a total order, otherwise the B+ tree cannot be sorted.
    inline bool key_equal(const key_type &a, const key_type &b) const
    {
        return !m_key_less(a, b) && !m_key_less(b, a);
    }

public:
    // *** Allocators

    /// Return the base node allocator provided during construction.
    allocator_type get_allocator() const
    {
        return m_allocator;
    }

private:
    // *** Node Object Allocation and Deallocation Functions

    /// Return an allocator for leaf_node objects
    typename leaf_node::alloc_type leaf_node_allocator()
    {
        return typename leaf_node::alloc_type(m_allocator);
    }

    /// Return an allocator for inner_node objects
    typename inner_node::alloc_type inner_node_allocator()
    {
        return typename inner_node::alloc_type(m_allocator);
    }

    /// Allocate and initialize a leaf node
    inline leaf_node* allocate_leaf_buffer(Buffer& buffer)
    {
        leaf_node *n = buffer.emplaceAppend<leaf_node>();
        n->initialize();
        m_stats.leaves++;
        return n;
    }

    /// Allocate and initialize an inner node
    inline inner_node* allocate_inner_buffer(unsigned short level,
                                             Buffer& buffer)
    {
        inner_node *n = buffer.emplaceAppend<inner_node>();
        n->initialize(level);
        m_stats.innernodes++;
        return n;
    }

    /// Write a tombstone in logBuffer for the object corresponding
    /// to the tree node that needs to be deleted
    inline void free_node(NodeId nodeId)
    {
        Key key(treeTableId, &nodeId, sizeof(NodeId));
        Status status = objMgr->writeTombstone(key, &logBuffer);
        assert(status == STATUS_OK);
        numEntries++;
        if (nodeId == m_rootId)
            resetNextNodeId();
    }

    /// This function is called when the tree becomes empty
    inline void resetNextNodeId()
    {
        nextNodeId = ROOT_ID;
    }

    /// Updates tree statistics useful for testing.
    inline void updateLeafCount()
    {
        m_stats.leaves--;
    }

    /// Updates tree statistics useful for testing.
    inline void updateInnerCount()
    {
        m_stats.innernodes--;
    }

    /// Convenient template function for conditional copying of slotdata. This
    /// should be used instead of std::copy for all slotdata manipulations.
    template<class InputIterator, class OutputIterator>
    static OutputIterator data_copy (InputIterator first, InputIterator last,
                                     OutputIterator result)
    {
        if (used_as_set) return result; // no operation
        else return std::copy(first, last, result);
    }

    /// Convenient template function for conditional copying of slotdata. This
    /// should be used instead of std::copy for all slotdata manipulations.
    template<class InputIterator, class OutputIterator>
    static OutputIterator data_copy_backward (InputIterator first, InputIterator last,
                                              OutputIterator result)
    {
        if (used_as_set) return result; // no operation
        else return std::copy_backward(first, last, result);
    }

    // *** Helper functions to allow using RamCloud objects for B+ tree nodes

    /**
     * Read the node(RamCloud object) corresponding to a given nodeId
     * and return a pointer to a contiguous copy of the same in memory
     *
     * \param nodeId
     *      This will be the primary key for the RamCloud object corresponding
     *      to a B+ tree node.
     * \param[out] outBuffer
     *      Buffer to hold the contents of the object. The caller must ensure
     *      that this is NOT NULL.
     * \return
     *      A pointer to a contiguous copy of the object in memory.
     *      It will be be copied if it is not already contiguous
     */ 
    const void* getPointerToObject(NodeId nodeId, Buffer* outBuffer) const
    {
        Key key(treeTableId, &nodeId, sizeof(NodeId));
        Status status = objMgr->readObject(key, outBuffer, NULL, NULL, true);
        if (status != STATUS_OK) {
            RAMCLOUD_LOG(ERROR, "Cant read NodeId %lu", nodeId);
            assert(status == STATUS_OK);
        }
        RAMCLOUD_LOG(DEBUG, "Read object from log, nodeId = %lu, size = %d",
                     nodeId, outBuffer->size());
        return outBuffer->getRange(0, outBuffer->size());
    }

    /**
     * Write a B+ tree node as a RamCloud object
     *
     * \param node
     *      This points to the contents of the B+ tree node
     * \param size 
     *      The size in bytes of this B+ tree node
     * \param nodeId
     *      The nodeId (primary key) for the new object that will be
     *      written out in this function. This argument is ignored
     *      if #useGlobalNodeId is true. This typically happens at
     *      the "end" of a tree update operation. The "end" here
     *      corresponds to a commit point for tree consistency. The
     *      caller will reuse the nodeId for this node in this case
     * \param useGlobalNodeId
     *      If true, the primary key for this object will be chosen
     *      as nextNodeId which is global to the tree.
     * \return
     *      The nodeId (primary key) used for this object.
     */
    NodeId writeNode(const void* node, unsigned int size,
                     NodeId nodeId = 0, bool useGlobalNodeId = true)
    {
        NodeId nodeIdUsed;

        if (useGlobalNodeId)
            nodeIdUsed = nextNodeId++;
        else
            nodeIdUsed = nodeId;

        Key key(treeTableId, &nodeIdUsed, sizeof(NodeId));

        RAMCLOUD_LOG(DEBUG, "Writing key(nodeId) is %lu, size of node = %d",
                     nodeIdUsed, size);

        Buffer buffer;
        // Avoid version 0 to avoid confusion
        Object object(key, node, size, 1, 0, buffer);

        // here size is the size of the object's value. ObjectManager
        // will construct an object around this.
        bool tombstoneAdded = false;
        uint32_t nodeOffset = 0;
        Status status = objMgr->prepareForLog(object, &logBuffer,
                                           &nodeOffset, &tombstoneAdded);

        cache[nodeIdUsed] = nodeOffset;

        if (tombstoneAdded)
            numEntries+= 2;
        else
            numEntries++;

        assert(status == STATUS_OK);
        return nodeIdUsed;
    }

    /**
     * Creates a mutable copy of a given leaf node. The contents of the mutable
     * copy are kept in a buffer that is passed through a NodeObjectInfo variable 
     * 
     * \param leaf
     *      Constant pointer to a leaf node
     * \param mutableLeafInfo
     *      Contains the buffer to hold the contents of the mutable copy and a
     *      pointer to the mutable copy itself. Caller must ensure this is not
     *      NULL
     */
    void createMutableLeaf(const leaf_node* leaf, NodeObjectInfo *mutableLeafInfo)
    {
        mutableLeafInfo->data = mutableLeafInfo->buffer.emplaceAppend<
                leaf_node>();
        memcpy(mutableLeafInfo->data, leaf, sizeof(leaf_node));
    }

     /**
     * Creates a mutable copy of a given inner node. The contents of the mutable
     * copy are kept in a buffer that is passed through a NodeObjectInfo variable 
     * 
     * \param inner
     *      Constant pointer to a inner node
     * \param[out] mutableInnerInfo
     *      Contains the buffer to hold the contents of the mutable copy and a
     *      pointer to the mutable copy itself. Caller must ensure this is not
     *      NULL
     */
    void createMutableInner(const inner_node* inner, NodeObjectInfo *mutableInnerInfo)
    {
        mutableInnerInfo->data = mutableInnerInfo->buffer.emplaceAppend<
                inner_node>();
        memcpy(mutableInnerInfo->data, inner, sizeof(inner_node));
    }   

public:
    // *** Fast Destruction of the B+ Tree

    /// Frees all key/data pairs and all nodes of the tree
    /// Resets metadata about the tree. The actual nodes (RamCloud objects)
    /// corresponding to the treeTable will get deleted when Frees all key/data pairs and all nodes of the tree
    void clear()
    {
        if (nextNodeId > ROOT_ID)
        {
            nextNodeId = ROOT_ID;
            m_stats = tree_stats();
            cache.clear();
        }
        BTREE_ASSERT(m_stats.itemcount == 0);
    }

private:
    /// Recursively free up nodes
    void clear_recursive(NodeId nodeId)
    {
        Buffer buffer;
        const node *n = static_cast<const node *>(getPointerToObject(nodeId, &buffer));
        if (n->isleafnode())
        {
            const leaf_node *leafnode = static_cast<const leaf_node*>(n);

            for (unsigned int slot = 0; slot < leafnode->slotuse; ++slot)
            {
                // data objects are deleted by leaf_node's destructor
            }
        }
        else
        {
            const inner_node *innernode = static_cast<const inner_node*>(n);

            for (unsigned short slot = 0; slot < innernode->slotuse + 1; ++slot)
            {
                clear_recursive(innernode->childid[slot]);
                free_node(innernode->childid[slot]);
                // we are deleting leaves in this case
                if (innernode->level == 1)
                    updateLeafCount();
                else
                    updateInnerCount();
            }
        }
    }

public:
    // *** STL Iterator Construction Functions

    /// Constructs a read/data-write iterator that points to the first slot in
    /// the first leaf of the B+ tree.
    inline iterator begin()
    {
        if (nextNodeId <= ROOT_ID)
            return iterator(this, INVALID_NODEID, 0);

        NodeId currentId = m_rootId;
        Buffer nodeBuffer;
        const node *n = static_cast<const node*>(getPointerToObject(currentId,
                                                                    &nodeBuffer));
        while (!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);

            currentId = inner->childid[0];
            nodeBuffer.reset();
            n = static_cast<const node *>(getPointerToObject(currentId, &nodeBuffer));
        }

        return iterator(this, currentId, 0); 
    }

    /// Constructs a read/data-write iterator that points to the first invalid
    /// slot in the last leaf of the B+ tree.
    inline iterator end()
    {
        return iterator(this, INVALID_NODEID, 0);
    }

private:
    // *** B+ Tree Node Binary Search Functions

    /// Searches for the first key in the node n greater or equal to key. Uses
    /// binary search with an optional linear self-verification. This is a
    /// template function, because the slotkey array is located at different
    /// places in leaf_node and inner_node.
    template <typename node_type>
    inline int find_lower(const node_type *n, const key_type& key) const
    {
        if ( 0 && sizeof(n->slotkey) > traits::binsearch_threshold )
        {
            if (n->slotuse == 0) return 0;

            int lo = 0, hi = n->slotuse;

            while (lo < hi)
            {
                int mid = (lo + hi) >> 1;

                if (key_lessequal(key, n->slotkey[mid])) {
                    hi = mid; // key <= mid
                }
                else {
                    lo = mid + 1; // key > mid
                }
            }

            BTREE_PRINT("btree::find_lower: on " << n << " key " << key << " -> " << lo << " / " << hi);

            // verify result using simple linear search
            if (selfverify)
            {
                int i = 0;
                while (i < n->slotuse && key_less(n->slotkey[i],key)) ++i;

                BTREE_PRINT("btree::find_lower: testfind: " << i);
                BTREE_ASSERT(i == lo);
            }

            return lo;
        }
        else // for nodes <= binsearch_threshold do linear search.
        {
            int lo = 0;
            while (lo < n->slotuse && key_less(n->slotkey[lo],key)) ++lo;
            return lo;
        }
    }

    /// Searches for the first key in the node n greater than key. Uses binary
    /// search with an optional linear self-verification. This is a template
    /// function, because the slotkey array is located at different places in
    /// leaf_node and inner_node.
    template <typename node_type>
    inline int find_upper(const node_type *n, const key_type& key) const
    {
        if ( 0 && sizeof(n->slotkey) > traits::binsearch_threshold )
        {
            if (n->slotuse == 0) return 0;

            int lo = 0, hi = n->slotuse;

            while (lo < hi)
            {
                int mid = (lo + hi) >> 1;

                if (key_less(key, n->slotkey[mid])) {
                    hi = mid; // key < mid
                }
                else {
                    lo = mid + 1; // key >= mid
                }
            }

            BTREE_PRINT("btree::find_upper: on " << n << " key " << key << " -> " << lo << " / " << hi);

            // verify result using simple linear search
            if (selfverify)
            {
                int i = 0;
                while (i < n->slotuse && key_lessequal(n->slotkey[i],key)) ++i;

                BTREE_PRINT("btree::find_upper testfind: " << i);
                BTREE_ASSERT(i == hi);
            }

            return lo;
        }
        else // for nodes <= binsearch_threshold do linear search.
        {
            int lo = 0;
            while (lo < n->slotuse && key_lessequal(n->slotkey[lo],key)) ++lo;
            return lo;
        }
    }

public:
    // *** Access Functions to the Item Count

    /// Return the number of key/data pairs in the B+ tree
    inline size_type size() const
    {
        // this check has to work after a crash recovery also
        // We really can't rely on the exact count of the nodes
        // in the tree but we can be sure whether or not the
        // tree is empty because 'nextNodeId' will be recovered
        // during recovery of this b-tree
        if (nextNodeId <= ROOT_ID)
            return 0;
        else
            return m_stats.itemcount;
    }

    /// Returns true if there is at least one key/data pair in the B+ tree
    inline bool empty() const
    {
        return (size() == size_type(0));
    }

    /// Returns the largest possible size of the B+ Tree. This is just a
    /// function required by the STL standard, the B+ Tree can hold more items.
    inline size_type max_size() const
    {
        return size_type(-1);
    }

    /// Return a const reference to the current statistics.
    inline const struct tree_stats& get_stats() const
    {
        return m_stats;
    }

public:
    // *** Standard Access Functions Querying the Tree by Descending to a Leaf

    /// Non-STL function checking whether a key is in the B+ tree. The same as
    /// (find(k) != end()) or (count() != 0).
    bool exists(const key_type &key) const
    {
        if (nextNodeId <= ROOT_ID)
            return false;

        Buffer rootBuffer;
        const node *n = static_cast<const node *>(getPointerToObject(m_rootId,
                                                                     &rootBuffer));
        Buffer nodeBuffer;
        while (!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            NodeId childId = inner->childid[slot];
            nodeBuffer.reset();
            n = static_cast<const node *>(getPointerToObject(childId, &nodeBuffer));
        }

        const leaf_node *leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]));
    }

    /// Tries to locate a key in the B+ tree and returns an iterator to the
    /// key/data slot if found. If unsuccessful it returns end().
    iterator find(const key_type &key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer rootBuffer;
        const node *n = static_cast<const node *>(getPointerToObject(m_rootId, &rootBuffer));
        Buffer nodeBuffer;
        NodeId childId = m_rootId;
        while(!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            childId = inner->childid[slot];
            nodeBuffer.reset();
            n = static_cast<const node*>(getPointerToObject(childId, &nodeBuffer));
        }

        assert (childId >= ROOT_ID);
        const leaf_node *leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
            ? iterator(this, childId, slot) : end();
    }

    /// Tries to locate a key in the B+ tree and returns the number of
    /// identical key entries found.
    size_type count(const key_type &key) const
    {
        if (nextNodeId <= ROOT_ID)
            return 0;

        Buffer rootBuffer;
        NodeId childId = m_rootId;
        const node *n = static_cast<const node *>(getPointerToObject(m_rootId, &rootBuffer));
        Buffer nodeBuffer;
        while(!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            childId = inner->childid[slot];
            nodeBuffer.reset();
            n = static_cast<const node*>(getPointerToObject(childId, &nodeBuffer));
        }

        const leaf_node *leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);
        size_type num = 0;

        NodeId currentLeafId = childId;
        Buffer leafBuffer;
        while (currentLeafId != INVALID_NODEID &&
               slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
        {
            ++num;
            if (++slot >= leaf->slotuse)
            {
                slot = 0;

                currentLeafId = leaf->nextleaf;
                leafBuffer.reset();

                if (currentLeafId == INVALID_NODEID)
                    break;

                leaf = static_cast<const leaf_node*>(
                            getPointerToObject(currentLeafId, &leafBuffer));
            }
        }

        return num;
    }

    /// Searches the B+ tree and returns an iterator to the first pair
    /// equal to or greater than key, or end() if all keys are smaller.
    iterator lower_bound(const key_type& key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer rootBuffer;
        const node *n = static_cast<const node *>(getPointerToObject(m_rootId, &rootBuffer));
        Buffer nodeBuffer;
        NodeId childId = m_rootId;
        while(!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            int slot = find_lower(inner, key);

            childId = inner->childid[slot];
            nodeBuffer.reset();
            n = static_cast<const node*>(getPointerToObject(childId, &nodeBuffer));
        }

        const leaf_node *leaf = static_cast<const leaf_node*>(n);

        int slot = find_lower(leaf, key);

        // If the slot returned by find_upper() is beyond the last element
        // in use, return end()
        if (slot >= leaf->slotuse)
            return end();
        else
            return iterator(this, childId, slot);
    }

    /// Searches the B+ tree and returns an iterator to the first pair
    /// greater than key, or end() if all keys are smaller or equal.
    iterator upper_bound(const key_type& key)
    {
        if (nextNodeId <= ROOT_ID)
            return end();

        Buffer rootBuffer;
        const node *n = static_cast<const node *>(getPointerToObject(m_rootId, &rootBuffer));
        Buffer nodeBuffer;
        NodeId childId = m_rootId;
        while(!n->isleafnode())
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            int slot = find_upper(inner, key);

            childId = inner->childid[slot];
            nodeBuffer.reset();
            n = static_cast<const node*>(getPointerToObject(childId, &nodeBuffer));
        }

        const leaf_node *leaf = static_cast<const leaf_node*>(n);

        int slot = find_upper(leaf, key);

        // If the slot returned by find_upper() is beyond the last element
        // in use, return end()
        if (slot >= leaf->slotuse)
            return end();
        else
            return iterator(this, childId, slot);
    }

    /// Searches the B+ tree and returns both lower_bound() and upper_bound().
    inline std::pair<iterator, iterator> equal_range(const key_type& key)
    {
        return std::pair<iterator, iterator>(lower_bound(key), upper_bound(key));
    }

public:
    // *** B+ Tree Object Comparison Functions

    /// Equality relation of B+ trees of the same type. B+ trees of the same
    /// size and equal elements (both key and data) are considered
    /// equal. Beware of the random ordering of duplicate keys.
    inline bool operator==(const btree_self &other) const
    {
        return (size() == other.size()) && std::equal(begin(), end(), other.begin());
    }

    /// Inequality relation. Based on operator==.
    inline bool operator!=(const btree_self &other) const
    {
        return !(*this == other);
    }

    /// Total ordering relation of B+ trees of the same type. It uses
    /// std::lexicographical_compare() for the actual comparison of elements.
    inline bool operator<(const btree_self &other) const
    {
        return std::lexicographical_compare(begin(), end(), other.begin(), other.end());
    }

    /// Greater relation. Based on operator<.
    inline bool operator>(const btree_self &other) const
    {
        return other < *this;
    }

    /// Less-equal relation. Based on operator<.
    inline bool operator<=(const btree_self &other) const
    {
        return !(other < *this);
    }

    /// Greater-equal relation. Based on operator<.
    inline bool operator>=(const btree_self &other) const
    {
        return !(*this < other);
    }

public:
    // *** Public Insertion Functions

    /// Attempt to insert a key/data pair into the B+ tree. If the tree does not
    /// allow duplicate keys, then the insert may fail if it is already
    /// present.
    inline std::pair<iterator, bool> insert(const pair_type& x)
    {
        return insert_start(x.first, x.second);
    }

    /// Attempt to insert a key/data pair into the B+ tree. Beware that if
    /// key_type == data_type, then the template const_iterator insert() is called
    /// instead. If the tree does not allow duplicate keys, then the insert may
    /// fail if it is already present.
    inline std::pair<iterator, bool> insert(const key_type& key, const data_type& data)
    {
        return insert_start(key, data);
    }

    /// Attempt to insert a key/data pair into the B+ tree. This function is the
    /// same as the other insert, however if key_type == data_type then the
    /// non-template function cannot be called. If the tree does not allow
    /// duplicate keys, then the insert may fail if it is already present.
    inline std::pair<iterator, bool> insert2(const key_type& key, const data_type& data)
    {
        return insert_start(key, data);
    }

    /// Attempt to insert a key/data pair into the B+ tree. The iterator hint
    /// is currently ignored by the B+ tree insertion routine.
    inline iterator insert(iterator /* hint */, const pair_type &x)
    {
        return insert_start(x.first, x.second).first;
    }

    /// Attempt to insert a key/data pair into the B+ tree. The iterator hint is
    /// currently ignored by the B+ tree insertion routine.
    inline iterator insert2(iterator /* hint */, const key_type& key, const data_type& data)
    {
        return insert_start(key, data).first;
    }

    /// Attempt to insert the range [first,last) of value_type pairs into the
    /// B+ tree. Each key/data pair is inserted individually; to bulk load the
    /// tree, use a constructor with range.
    template <typename InputIterator>
    inline void insert(InputIterator first, InputIterator last)
    {
        InputIterator iter = first;
        while(iter != last)
        {
            insert(*iter);
            ++iter;
        }
    }

private:
    // *** Private Insertion Functions

    /// Start the insertion descent at the current root and handle root
    /// splits. Returns true if the item was inserted
    std::pair<iterator, bool> insert_start(const key_type& key, const data_type& value)
    {
        key_type newkey = key_type();
        bool treeWasEmpty = false, newChildForRoot = false;

        Buffer rootBuffer;
        node *root = NULL;
        // empty tree
        if (nextNodeId <= ROOT_ID) {
            treeWasEmpty = true;
            root = allocate_leaf_buffer(rootBuffer);
            nextNodeId++;
        }

        bool newChildCreated = false;
        NodeObjectInfo rootInfo, childInfo;

        // when tree is empty, the (new) root is not written before a call
        // to insert_descend(). But insert_descend() attempts to read the
        // corresponding object from the log. So, distinguish these cases.
        std::pair<iterator, bool> r =
                                insert_descend(m_rootId, &rootInfo, key,
                                               value, &newkey,&newChildCreated,
                                               &childInfo, treeWasEmpty, root);

        if (newChildCreated)
        {
            Buffer buffer;
            // read root object to get the level.
            unsigned short rootLevel = (static_cast<node *>(rootInfo.data))->level;
            inner_node *newroot = allocate_inner_buffer(rootLevel + 1,
                                                        buffer);
            newroot->slotkey[0] = newkey;

            newroot->childid[0] = rootInfo.nodeId;
            newroot->childid[1] = childInfo.nodeId;

            newroot->slotuse = 1;

            writeNode(newroot, sizeof(inner_node), m_rootId, false);
        }

        // increment itemcount if the item was inserted
        if (r.second) ++m_stats.itemcount;

        if (selfverify) {
            verify();
            BTREE_ASSERT(exists(key));
        }

        bool status = objMgr->flushEntriesToLog(&logBuffer, numEntries);
        assert(status == true);
        cache.clear();
        return r;
    }

    /**
     * @brief Insert an item into the B+ tree.
     *
     * Descend down the nodes to a leaf, insert the key/data pair in a free
     * slot. If the node overflows, then it must be split and the new split
     * node inserted into the parent. Unroll / this splitting up to the root.
    */
    std::pair<iterator, bool> insert_descend(NodeId currentId, NodeObjectInfo* newNodeObjectInfo,
                                             const key_type& key, const data_type& value,
                                             key_type* splitkey, bool *newSplitCreated,
                                             NodeObjectInfo* newSplitNodeInfo,
                                             bool treeEmpty = false, const node *root = NULL)
    {
        RAMCLOUD_LOG(DEBUG, "NodeId %lu Entered insert_descend() function", currentId);
        RAMCLOUD_LOG(DEBUG, "Printing key = %s", std::string((const char*)&key, 40).c_str());

        // if treeEmpty is true, then the 'root' argument can NOT be NULL
        // We expect memory for root to have been allocated by the caller
        Buffer currentBuffer;
        const node *n;
        if (treeEmpty)
            n = root;
        else
            n = static_cast<const node *>(getPointerToObject(currentId, &currentBuffer));
        bool insertionAtSplitNode = false;
        if (!n->isleafnode())
        {
            const inner_node *constInner = static_cast<const inner_node*>(n);

            key_type newkey = key_type();
            bool newChildCreated = false;
            NodeObjectInfo newChildInfo, updatedInnerChildInfo;

            int slot = find_lower(constInner, key);

            BTREE_PRINT("btree::insert_descend into " << constInner->childid[slot]);

            RAMCLOUD_LOG(DEBUG, "btree::insert_descend into nodeId %lu", constInner->childid[slot]);

            std::pair<iterator, bool> r = insert_descend(constInner->childid[slot], &updatedInnerChildInfo,
                                                         key, value, &newkey, &newChildCreated, &newChildInfo);

            if (newChildCreated)
            {
                BTREE_PRINT("btree::insert_descend newchild with key " << newkey << " node " << newChildInfo.data <<
                            " at slot " << slot);

                // allocate a new inner node, make a copy of inner and
                // update the new node as follows
                createMutableInner(constInner, newNodeObjectInfo);
                inner_node *inner = static_cast<inner_node*>(
                                        newNodeObjectInfo->data);
                // inner is now a mutable pointer

                // The below statement is not required because we know for a
                // fact that the child at 'slot' would have been written with
                // the same nodeId it previously had

                // inner->childid[slot] = updatedInnerChildInfo.nodeId;

                if (inner->isfull())
                {
                    RAMCLOUD_LOG(DEBUG, "Splitting Inner node");
                    split_inner_node(inner, newNodeObjectInfo, splitkey, newSplitNodeInfo, slot);
                    node* splitnode = static_cast<node *>(newSplitNodeInfo->data);
                    *newSplitCreated = true;
                    // have to eventually write out inner and the split node 
                    
                    BTREE_PRINT("btree::insert_descend done split_inner: putslot: " << slot << " putkey: " << newkey << " upkey: " << *splitkey);

                    // check if insert slot is in the split sibling node
                    BTREE_PRINT("btree::insert_descend switch: " << slot << " > " << inner->slotuse+1);

                    if (slot == inner->slotuse+1 && inner->slotuse < (splitnode)->slotuse)
                    {
                        // special case when the insert slot matches the split
                        // place between the two nodes, then the insert key
                        // becomes the split key.

                        BTREE_ASSERT(inner->slotuse + 1 < innerslotmax);

                        inner_node *splitinner = static_cast<inner_node*>(splitnode);

                        // move the split key and it's datum into the left node
                        inner->slotkey[inner->slotuse] = *splitkey;
                        inner->childid[inner->slotuse+1] = splitinner->childid[0];
                        inner->slotuse++;

                        // set new split key and move corresponding datum into right node
                        splitinner->childid[0] = newChildInfo.nodeId;

                        // If root gets split, don't reuse nodeId for current root
                        if (currentId == m_rootId)
                            newNodeObjectInfo->nodeId =
                                            writeNode(inner, sizeof(inner_node));
                        else
                            newNodeObjectInfo->nodeId =
                                            writeNode(inner, sizeof(inner_node),
                                                      currentId, false);

                        newSplitNodeInfo->nodeId = writeNode(splitinner, sizeof(inner_node));
                        newNodeObjectInfo->data = inner;
                        newSplitNodeInfo->data = splitinner;
                        *splitkey = newkey;

                        return r;
                    }
                    else if (slot >= inner->slotuse+1)
                    {
                        // in case the insert slot is in the newly create split
                        // node, we reuse the code below.

                        insertionAtSplitNode = true;
                        slot -= inner->slotuse+1;

                        // If root gets split, don't reuse id for current root
                        if (currentId == m_rootId)
                            newNodeObjectInfo->nodeId =
                                            writeNode(inner, sizeof(inner_node));
                        else
                            newNodeObjectInfo->nodeId =
                                            writeNode(inner, sizeof(inner_node),
                                                      currentId, false);

                        newNodeObjectInfo->data = inner;
                        inner = static_cast<inner_node*>(splitnode);
                        BTREE_PRINT("btree::insert_descend switching to splitted node " << inner << " slot " << slot);
                    }
                    else
                    {
                        // write splitnode here
                        newSplitNodeInfo->nodeId =
                                                writeNode(splitnode,
                                                          sizeof(inner_node));
                        newSplitNodeInfo->data = splitnode;
                    }
                }
                else
                {
                    *newSplitCreated = false;
                }

                // move items and put pointer to child node into correct slot
                BTREE_ASSERT(slot >= 0 && slot <= inner->slotuse);

                std::copy_backward(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                                   inner->slotkey + inner->slotuse+1);
                std::copy_backward(inner->childid + slot, inner->childid + inner->slotuse+1,
                                   inner->childid + inner->slotuse+2);

                inner->slotkey[slot] = newkey;
                inner->childid[slot + 1] = newChildInfo.nodeId;
                inner->slotuse++;

                if (!insertionAtSplitNode)
                {
                    // If root gets split, don't reuse id for current root
                    if (*newSplitCreated && currentId == m_rootId)
                        newNodeObjectInfo->nodeId =
                                        writeNode(inner, sizeof(inner_node));
                    else
                        newNodeObjectInfo->nodeId =
                                        writeNode(inner, sizeof(inner_node),
                                                  currentId, false);

                    newNodeObjectInfo->data = inner;
                }
                else
                {
                    newSplitNodeInfo->data = inner;
                    newSplitNodeInfo->nodeId = writeNode(inner,
                                                         sizeof(inner_node));
                }
            }

            return r;
        }
        else // n->isleafnode() == true
        {
            const leaf_node *constLeaf = static_cast<const leaf_node*>(n);

            int slot = find_lower(constLeaf, key);

            if (!allow_duplicates && slot < constLeaf->slotuse &&
                key_equal(key, constLeaf->slotkey[slot])) {
                return std::pair<iterator, bool>(iterator(this, currentId, slot), false);
            }

            createMutableLeaf(constLeaf, newNodeObjectInfo);
            leaf_node *leaf = static_cast<leaf_node *>(newNodeObjectInfo->data);
            NodeId newLeafId = currentId;
            NodeId splitNodeId;

            if (leaf->isfull())
            {
                RAMCLOUD_LOG(DEBUG, "Splitting leaf node");
                split_leaf_node(leaf, splitkey, newSplitNodeInfo);
                // leaf is now a mutable pointer
                node* splitnode = static_cast<node *>(newSplitNodeInfo->data);
                *newSplitCreated = true;

                // If the root is split, rewrite the current root using a
                // new NodeId so that the new root can have NodeId = m_rootId
                if (currentId == m_rootId)
                    newLeafId = nextNodeId++;
                else
                    newLeafId = currentId;

                splitNodeId = nextNodeId++;

                RAMCLOUD_LOG(DEBUG, "newleaf ID = %lu, splitNodeId = %lu",
                                    newLeafId, splitNodeId);

                // adjust the nextleaf and the prevleaf nodeId values for
                // the relevant nodes
                leaf_node *newleaf = static_cast<leaf_node *>(splitnode);
                newleaf->nextleaf = leaf->nextleaf;

                // fix and the 'previous pointer (nodeId)' of the next leaf
                if (newleaf->nextleaf != INVALID_NODEID) {
                    Buffer buffer;
                    const leaf_node *constNextLeaf = static_cast<const leaf_node*>(
                                                getPointerToObject(newleaf->nextleaf,
                                                                   &buffer));
                    NodeObjectInfo nextLeafInfo;
                    createMutableLeaf(constNextLeaf, &nextLeafInfo);
                    leaf_node *nextLeaf = static_cast<leaf_node*>(nextLeafInfo.data);
                    nextLeaf->prevleaf = splitNodeId;
                    // rewrite nextLeaf with same NodeId
                    writeNode(nextLeaf, sizeof(leaf_node), newleaf->nextleaf, false);
                }

                // the newly split node will be written with NodeId
                // 'splitNodeId' and 'leaf' will be written with NodeId
                // newLeafId
                leaf->nextleaf = splitNodeId;
                newleaf->prevleaf = newLeafId;

                RAMCLOUD_LOG(DEBUG, "Checking if insert slot is in the split"
                                    "sibling node, slot = %d,"
                                    "leaf->slotuse = %d", slot, leaf->slotuse);
                // check if insert slot is in the split sibling node
                if (slot >= leaf->slotuse)
                {
                    insertionAtSplitNode = true;
                    slot -= leaf->slotuse;
                    // write out leaf object here
                    newNodeObjectInfo->nodeId =
                                    writeNode(leaf, sizeof(leaf_node),
                                              newLeafId, false);
                    newNodeObjectInfo->data = leaf;
                    leaf = static_cast<leaf_node*>(splitnode);
                }
                else
                {
                    // write splitnode here
                    // newleaf is the new node created after a split
                    // splitnode also points to this node
                    newSplitNodeInfo->nodeId = writeNode(newleaf,
                                                         sizeof(leaf_node),
                                                         splitNodeId, false);
                }
            }
            else
            {
                *newSplitCreated = false;
            }

            // move items and put data item into correct data slot
            BTREE_ASSERT(slot >= 0 && slot <= leaf->slotuse);

            std::copy_backward(leaf->slotkey + slot, leaf->slotkey + leaf->slotuse,
                               leaf->slotkey + leaf->slotuse+1);
            data_copy_backward(leaf->slotdata + slot, leaf->slotdata + leaf->slotuse,
                               leaf->slotdata + leaf->slotuse+1);

            leaf->slotkey[slot] = key;
            if (!used_as_set) leaf->slotdata[slot] = value;
            leaf->slotuse++;

            // write out leaf
            if (!insertionAtSplitNode)
            {
                newNodeObjectInfo->nodeId =
                                writeNode(leaf, sizeof(leaf_node),
                                          newLeafId, false);
                newNodeObjectInfo->data = leaf;
            }
            else
            {
                newSplitNodeInfo->data = leaf;
                // Should not reuse nodeId here since it is a new node in the
                // tree after all
                newSplitNodeInfo->nodeId = writeNode(leaf, sizeof(leaf_node),
                                                     splitNodeId, false);
            }

            if (*newSplitCreated && !insertionAtSplitNode && slot == leaf->slotuse-1)
            {
                // special case: the node was split, and the insert is at the
                // last slot of the old node. then the splitkey must be
                // updated.
                *splitkey = key;
            }

            if (insertionAtSplitNode)
                return std::pair<iterator, bool>(
                       iterator(this, newSplitNodeInfo->nodeId, slot), true);
            else
                return std::pair<iterator, bool>(
                       iterator(this, newLeafId, slot), true);
        }
    }

    /// Split up a leaf node into two equally-filled sibling leaves. Returns
    /// the new nodes and it's insertion key.
    void split_leaf_node(leaf_node* leaf, key_type* _newkey,
                         NodeObjectInfo* newLeafInfo)
    {
        // leaf is passed as a mutable pointer
        BTREE_ASSERT(leaf->isfull());

        unsigned int mid = (leaf->slotuse >> 1);

        BTREE_PRINT("btree::split_leaf_node on " << leaf);

        leaf_node *newleaf = allocate_leaf_buffer(newLeafInfo->buffer);

        newleaf->slotuse = leaf->slotuse - mid;

        std::copy(leaf->slotkey + mid, leaf->slotkey + leaf->slotuse,
                  newleaf->slotkey);
        data_copy(leaf->slotdata + mid, leaf->slotdata + leaf->slotuse,
                  newleaf->slotdata);

        // leaf and newleaf will be written after a call to this function
        // returns
        leaf->slotuse = mid;

        *_newkey = leaf->slotkey[leaf->slotuse-1];
        newLeafInfo->data = newleaf;
    }

    /// Split up an inner node into two equally-filled sibling nodes. Returns
    /// the new nodes and it's insertion key in the two parameters. Requires
    /// the slot of the item will be inserted, so the nodes will be the same
    /// size after the insert.
    void split_inner_node(inner_node* inner, NodeObjectInfo* innerInfo, key_type* _newkey,
                          NodeObjectInfo* newInnerInfo, unsigned int addslot)
    {
        BTREE_ASSERT(inner->isfull());

        unsigned int mid = (inner->slotuse >> 1);

        BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);

        // if the split is uneven and the overflowing item will be put into the
        // larger node, then the smaller split node may underflow
        if (addslot <= mid && mid > inner->slotuse - (mid + 1))
            mid--;

        BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);

        BTREE_PRINT("btree::split_inner_node on " << inner << " into two nodes " << mid << " and " << inner->slotuse - (mid + 1) << " sized");

        inner_node *newinner = allocate_inner_buffer(inner->level,
                                                newInnerInfo->buffer);

        newinner->slotuse = inner->slotuse - (mid + 1);

        std::copy(inner->slotkey + mid+1, inner->slotkey + inner->slotuse,
                  newinner->slotkey);
        std::copy(inner->childid + mid+1, inner->childid + inner->slotuse+1,
                  newinner->childid);

        // the caller will ensure that inner and newinner are written
        // after this function returns
        inner->slotuse = mid;
        
        *_newkey = inner->slotkey[mid];
        newInnerInfo->data = newinner;
    }

private:
    // *** Support Class Encapsulating Deletion Results

    /// Result flags of recursive deletion.
    enum result_flags_t
    {
        /// Deletion successful and no fix-ups necessary.
        btree_ok = 0,

        /// Deletion not successful because key was not found.
        btree_not_found = 1,

        /// Deletion successful, the last key was updated so parent slotkeys
        /// need updates.
        btree_update_lastkey = 2,

        /// Deletion successful, children nodes were merged and the parent
        /// needs to remove the empty node.
        btree_fixmerge = 4,

        /// Used by a parent to identify which child has to be deleted
        /// after a merge. So when this is set, btree_fixmerge is
        /// necessarily set
        btree_right_merge = 8
    };

    /// B+ tree recursive deletion has much information which is needs to be
    /// passed upward.
    struct result_t
    {
        /// Merged result flags
        result_flags_t  flags;

        /// The key to be updated at the parent's slot
        key_type        lastkey;

        /// Constructor of a result with a specific flag, this can also be used
        /// as for implicit conversion.
        inline result_t(result_flags_t f = btree_ok)
            : flags(f), lastkey()
        { }

        /// Constructor with a lastkey value.
        inline result_t(result_flags_t f, const key_type &k)
            : flags(f), lastkey(k)
        { }

        /// Test if this result object has a given flag set.
        inline bool has(result_flags_t f) const
        {
            return (flags & f) != 0;
        }

        /// Merge two results OR-ing the result flags and overwriting lastkeys.
        inline result_t& operator|= (const result_t &other)
        {
            flags = result_flags_t(flags | other.flags);

            // we overwrite existing lastkeys on purpose
            if (other.has(btree_update_lastkey))
                lastkey = other.lastkey;

            return *this;
        }
    };

public:
    // *** Public Erase Functions

    /// Erases one (the first) of the key/data pairs associated with the given
    /// key.
    bool erase_one(const key_type &key)
    {
        BTREE_PRINT("btree::erase_one(" << key << ") on btree size " << size());

        if (selfverify) verify();

        //if (!m_root) return false;
        if (nextNodeId <= ROOT_ID) return false;

        result_t result = erase_one_descend(key, m_rootId, NULL, NULL, NULL, NULL,
                                            NULL, 0, NULL);

        if (!result.has(btree_not_found))
            --m_stats.itemcount;

        if (selfverify) verify();

        bool status = objMgr->flushEntriesToLog(&logBuffer, numEntries);
        assert(status == true);
        cache.clear();
        return !result.has(btree_not_found);
    }

    /// Erases all the key/data pairs associated with the given key. This is
    /// implemented using erase_one().
    size_type erase(const key_type &key)
    {
        size_type c = 0;

        while( erase_one(key) )
        {
            ++c;
            if (!allow_duplicates) break;
        }

        return c;
    }

    /// Erase the key/data pair referenced by the iterator.
    void erase(iterator iter)
    {
        // Not implemented
    }

#ifdef BTREE_TODO
    /// Erase all key/data pairs in the range [first,last). This function is
    /// currently not implemented by the B+ Tree.
    void erase(iterator /* first */, iterator /* last */)
    {
        abort();
    }
#endif

private:
    // *** Private Erase Functions

    /** @brief Erase one (the first) key/data pair in the B+ tree matching key.
     *
     * Descends down the tree in search of key. During the descent the parent,
     * left and right siblings and their parents are computed and passed
     * down. Once the key/data pair is found, it is removed from the leaf. If
     * the leaf underflows 6 different cases are handled. These cases resolve
     * the underflow by shifting key/data pairs from adjacent sibling nodes,
     * merging two sibling nodes or trimming the tree.
     */
    result_t erase_one_descend(const key_type& key,
                               NodeId currentId,
                               const NodeId *left, const NodeId *right,
                               const inner_node *leftparent,
                               const inner_node *rightparent,
                               const inner_node *parent,
                               unsigned int parentslot,
                               NodeObjectInfo* newParentInfo)
    {
        // newParentInfo is used when there are updates to the parent that
        // need to be recorded in a new object. If parent is not NULL,
        // then newParentInfo will also be not NULL
        Buffer currentBuffer, parentBuffer;
        const node *curr = static_cast<const node *>(getPointerToObject(currentId,
                                                                        &currentBuffer));

        if (curr->isleafnode())
        {
            const leaf_node *constLeaf = static_cast<const leaf_node*>(curr);
            leaf_node *leftleaf, *rightleaf;
            Buffer leftBuffer, rightBuffer;

            NodeObjectInfo leftLeafInfo, rightLeafInfo;
            // create pointers to mutable copies of leftleaf and rightleaf
            if (left) {
                const leaf_node* constLeftLeaf = static_cast<const leaf_node *>(
                                                    getPointerToObject(*left,
                                                    &leftBuffer));
                createMutableLeaf(constLeftLeaf, &leftLeafInfo);
                leftleaf = static_cast<leaf_node *>(leftLeafInfo.data);
            } else {
                leftleaf = NULL;
            }
            if (right) {
                const leaf_node* constRightLeaf = static_cast<const leaf_node *>(
                                                    getPointerToObject(*right,
                                                    &rightBuffer));
                createMutableLeaf(constRightLeaf, &rightLeafInfo);
                rightleaf = static_cast<leaf_node *>(rightLeafInfo.data);
            } else {
                rightleaf = NULL;
            }

            int slot = find_lower(constLeaf, key);

            if (slot >= constLeaf->slotuse || !key_equal(key, constLeaf->slotkey[slot]))
            {
                BTREE_PRINT("Could not find key " << key << " to erase.");

                return btree_not_found;
            }

            BTREE_PRINT("Found key in leaf " << curr << " at slot " << slot);

            // removing one data pointer from the leaf. So, a new object for
            // leaf has to be written

            NodeObjectInfo updatedLeafInfo;
            createMutableLeaf(constLeaf, &updatedLeafInfo);
            // leaf is now mutable
            leaf_node *leaf = static_cast<leaf_node*>(updatedLeafInfo.data);

            std::copy(leaf->slotkey + slot+1, leaf->slotkey + leaf->slotuse,
                      leaf->slotkey + slot);
            data_copy(leaf->slotdata + slot+1, leaf->slotdata + leaf->slotuse,
                      leaf->slotdata + slot);

            leaf->slotuse--;

            result_t myres = btree_ok;

            // if the parent needs to be updated, this will point to the new
            // variant of the parent node with the updated information.
            // However, we will have to use the 'parent' pointer for pointer
            // comparisons with leftparent and rightparent
            inner_node *newParent = NULL;
            bool parentDirty = false;

            // if the last key of the leaf was changed, the parent is notified
            // and updates the key of this leaf
            if (slot == leaf->slotuse)
            {
                if (parent && parentslot < parent->slotuse)
                {
                    // updating one of the keys in the parent. So, have to write a
                    // new object for the parent.

                    createMutableInner(parent, newParentInfo);
                    // newParent is mutable
                    newParent = static_cast<inner_node *>(newParentInfo->data);
                    newParent->slotkey[parentslot] = leaf->slotkey[leaf->slotuse - 1];
                    parentDirty = true;
                }
                else
                {
                    if (leaf->slotuse >= 1)
                    {
                        BTREE_PRINT("Scheduling lastkeyupdate: key " << leaf->slotkey[leaf->slotuse - 1]);
                        // can happen if leaf is the last child of parent. So there is
                        // no need to update this the parent but instead some other node
                        // higher up for which this leaf falls under its left sub tree.
                        myres |= result_t(btree_update_lastkey, leaf->slotkey[leaf->slotuse - 1]);
                        // we are still propagating a change up the tree. We
                        // need to keep rewriting the nodes until we reach the 
                        // topmost node in the update sequence. This also means
                        // that we cannot reuse the nodeId for leaf
                        if (parent)
                        {
                            createMutableInner(parent, newParentInfo);
                            // newParent is mutable
                            newParent = static_cast<inner_node *>(newParentInfo->data);
                            parentDirty = true;
                        }
                    }
                    else
                    {
                        BTREE_ASSERT(currentId == m_rootId);
                    }
                }
            }

            if (leaf->isunderflow() && !(currentId == m_rootId && leaf->slotuse >= 1))
            {
                // determine what to do about the underflow

                // case : if this empty leaf is the root, then delete all nodes
                if (leftleaf == NULL && rightleaf == NULL)
                {
                    BTREE_ASSERT(currentId == m_rootId);
                    BTREE_ASSERT(leaf->slotuse == 0);

                    free_node(m_rootId);
                    updateLeafCount();

                    // will be decremented soon by insert_start()
                    BTREE_ASSERT(m_stats.itemcount == 1);
                    BTREE_ASSERT(m_stats.leaves == 0);
                    BTREE_ASSERT(m_stats.innernodes == 0);

                    return btree_ok;
                }
                // case : if both left and right leaves would underflow in case of
                // a shift, then merging is necessary. choose the more local merger
                // with our parent
                else
                {
                    if (newParentInfo->data == NULL)
                    {
                        createMutableInner(parent, newParentInfo);
                        // newParent is mutable
                        newParent = static_cast<inner_node *>(newParentInfo->data);
                        parentDirty = true;
                    }
                    if ( (leftleaf == NULL || leftleaf->isfew()) && (rightleaf == NULL || rightleaf->isfew()) )
                    {
                        if (leftparent == parent) {
                            myres |= merge_leaves(leftleaf, *left, leaf, newParent, parentslot - 1);
                        }
                        else {
                            myres |= merge_leaves(leaf, currentId, rightleaf, newParent, parentslot);
                            myres |= btree_right_merge;
                        }
                    }
                    // case : the right leaf has extra data, so balance right with current
                    else if ( (leftleaf != NULL && leftleaf->isfew()) && (rightleaf != NULL && !rightleaf->isfew()) )
                    {
                        if (rightparent == parent)
                            myres |= shift_left_leaf(leaf, currentId, rightleaf, *right, newParent, parentslot);
                        else
                            myres |= merge_leaves(leftleaf, *left, leaf, newParent, parentslot - 1);
                    }
                    // case : the left leaf has extra data, so balance left with current
                    else if ( (leftleaf != NULL && !leftleaf->isfew()) && (rightleaf != NULL && rightleaf->isfew()) )
                    {
                        if (leftparent == parent) {
                            shift_right_leaf(leftleaf, *left, leaf, currentId, newParent, parentslot - 1);
                        }
                        else {
                            myres |= merge_leaves(leaf, currentId, rightleaf, newParent, parentslot);
                            myres |= btree_right_merge;
                        }
                    }
                    // case : both the leaf and right leaves have extra data and our
                    // parent, choose the leaf with more data
                    else if (leftparent == rightparent)
                    {
                        if (leftleaf->slotuse <= rightleaf->slotuse)
                            myres |= shift_left_leaf(leaf, currentId, rightleaf, *right, newParent, parentslot);
                        else
                            shift_right_leaf(leftleaf, *left, leaf, currentId, newParent, parentslot - 1);
                    }
                    else
                    {
                        if (leftparent == parent)
                            shift_right_leaf(leftleaf, *left, leaf, currentId, newParent, parentslot - 1);
                        else
                            myres |= shift_left_leaf(leaf, currentId, rightleaf, *right, newParent, parentslot);
                    }
                }
            }
            // else check for reusing Id and write leaf
            else
            {
                // No underflow
                // write out leaf. We will never write parent here.
                // the caller will take care of that
                if (!myres.has(btree_not_found) &&
                    !myres.has(btree_update_lastkey) &&
                    !myres.has(btree_fixmerge) && !parentDirty)
                {
                    // reuse NodeId since this is the last update as part of
                    // the erase operation.
                    writeNode(leaf, sizeof(leaf_node), currentId, false);
                    // this to inform the parent that it was not modified by the child
                    if (newParentInfo)
                        newParentInfo->data = NULL;
                }
                else
                {
                    // newParent is guaranteed to be NOT NULL
                    if (parent)
                        newParent->childid[parentslot] = writeNode(leaf, sizeof(leaf_node),
                                                                   currentId, false);
                    else
                        // leaf is the root node. It still tries to forward
                        // update_lastkey up but it is of no use. The root
                        // has already been modified appropriately. Rewrite root
                        // object using same nodeId
                        writeNode(leaf, sizeof(leaf_node), m_rootId, false);
                }
            }

            return myres;
        }
        else // !curr->isleafnode()
        {
            const inner_node *constInner = static_cast<const inner_node*>(curr);
            inner_node *leftinner, *rightinner;
            Buffer leftBuffer, rightBuffer;

            NodeObjectInfo leftInnerInfo, rightInnerInfo;

            const NodeId *myleft, *myright;
            const inner_node *myleftparent, *myrightparent;

            // create pointers to mutable copies of leftinner and rightinner
            if (left) {
                const inner_node *constLeftInner = static_cast<const inner_node *>(
                                                    getPointerToObject(*left,
                                                    &leftBuffer));
                createMutableInner(constLeftInner, &leftInnerInfo);
                leftinner = static_cast<inner_node *>(leftInnerInfo.data);
            } else {
                leftinner = NULL;
            }
            if (right) {
                const inner_node *constRightInner = static_cast<const inner_node *>(
                                                    getPointerToObject(*right,
                                                    &rightBuffer));
                createMutableInner(constRightInner, &rightInnerInfo);
                rightinner = static_cast<inner_node *>(rightInnerInfo.data);
            } else {
                rightinner = NULL;
            }

            int slot = find_lower(constInner, key);

            if (slot == 0) {
                myleft = (left == NULL) ? NULL : &(leftinner->childid[leftinner->slotuse - 1]);
                myleftparent = leftparent;
            }
            else {
                myleft = &(constInner->childid[slot - 1]);
                myleftparent = constInner;
            }

            if (slot == constInner->slotuse) {
                myright = (right == NULL) ? NULL : &(rightinner->childid[0]);
                myrightparent = rightparent;
            }
            else {
                myright = &(constInner->childid[slot + 1]);
                myrightparent = constInner;
            } 
            BTREE_PRINT("erase_one_descend into " << constInner->childid[slot]);

            bool innerDirty = false;
            bool parentDirty = false;
            NodeObjectInfo newInnerInfo;
            newInnerInfo.data = NULL;

            result_t result = erase_one_descend(key,
                                                constInner->childid[slot],
                                                myleft, myright,
                                                myleftparent, myrightparent,
                                                constInner, slot, &newInnerInfo);

            // Inner was modified by its child in the recursive call above.
            // At the end of this function, write out inner only if
            // innnerDirty is true.
            inner_node *inner = NULL;
            if (newInnerInfo.data)
            {
                inner = static_cast<inner_node *>(newInnerInfo.data);
                innerDirty = true;
            }

            result_t myres = btree_ok;

            if (result.has(btree_not_found))
            {
                return result;
            }

            // To create a mutable pointer 
            inner_node *newParent = NULL;

            if (result.has(btree_update_lastkey))
            {
                if (parent && parentslot < parent->slotuse)
                {
                    BTREE_PRINT("Fixing lastkeyupdate: key " << result.lastkey << " into parent " << parent << " at parentslot " << parentslot);
		
                    BTREE_ASSERT(parent->childid[parentslot] == currentId);
                    // a new object for parent has to be written.
                    createMutableInner(parent, newParentInfo);
                    // newParent is mutable
                    newParent = static_cast<inner_node *>(newParentInfo->data);
                    newParent->slotkey[parentslot] = result.lastkey;
                    parentDirty = true;
                }
                else
                {
                    BTREE_PRINT("Forwarding lastkeyupdate: key " << result.lastkey);
                    myres |= result_t(btree_update_lastkey, result.lastkey);
                    // we are still propagating a change up the tree. We
                    // need to keep rewriting the nodes until we reach the 
                    // topmost node in the update sequence. This also means
                    // that we cannot reuse the nodeId for leaf
                    if (parent)
                    {
                        createMutableInner(parent, newParentInfo);
                        // newParent is mutable
                        newParent = static_cast<inner_node *>(newParentInfo->data);
                        parentDirty = true;
                    }
                }
            }

            if (result.has(btree_fixmerge))
            {
                // create a mutable copy of inner if not already created
                if (newInnerInfo.data == NULL)
                {
                    createMutableInner(constInner, &newInnerInfo);
                    inner = static_cast<inner_node *>(newInnerInfo.data);
                    innerDirty = true;
                }

                // either the current node or the next is empty and should be removed
                // check which child needs to be deleted
                if (result.has(btree_right_merge))
                    slot++;

                free_node(inner->childid[slot]);
                if (inner->level == 1)
                    updateLeafCount();
                else
                    updateInnerCount();

                // write a new variant of inner object after all below
                // modifications
                std::copy(inner->slotkey + slot, inner->slotkey + inner->slotuse,
                          inner->slotkey + slot-1);
                std::copy(inner->childid + slot+1, inner->childid + inner->slotuse+1,
                          inner->childid + slot);

                inner->slotuse--;

                if (inner->level == 1)
                {
                    // IMPORTANT. It is possible that 'result' has fix_merge
                    // and update_lastkey set. Since parent does not exist in
                    // this case, update_lastkey will be forwarded up by the
                    // earlier 'if' block and inner's split key will be fixed
                    // below. But at the end of this function, we assume that
                    // if myres.has(btree_update_lastkey), then parent and hence
                    // newParent exists. This is not true if inner == root
                    // fix split key for children leaves
                    slot--;

                    // first lookup in the cache to see if this child was
                    // recently modified. If not, read from the log.
                    // This order of checking is important
                    Buffer buffer;
                    const leaf_node *child = NULL;
                    std::map<NodeId, uint32_t>::iterator it =
                                    cache.find(inner->childid[slot]);
                    if (it != cache.end()) {
                        child = reinterpret_cast<const leaf_node*>(
                                    logBuffer.getRange(it->second,
                                    sizeof(leaf_node)));
                    } else {
                        child = static_cast<const leaf_node*>(
                                                getPointerToObject(inner->childid[slot],
                                                                   &buffer));
                    }

                    inner->slotkey[slot] = child->slotkey[ child->slotuse-1 ];
                }
            }

            // If the recursive call returns btree_ok, then 'inner' will be
            // NULL here. But we also cannot use constInner in this check
            // because if the recursive call does not return btree_ok,
            // inner would have been modified in the child recursive call.
            // In this case, we should use 'inner' in the if condition.

            //if (inner->isunderflow() && !(currentId == m_rootId && inner->slotuse >= 1))
            if ((newInnerInfo.data && inner->isunderflow() && !(currentId == m_rootId && inner->slotuse >= 1))
                || (constInner->isunderflow() && !(currentId == m_rootId && constInner->slotuse >= 1)))
            {
                // If we are inside this 'if', it means that inner cannot be
                // NULL. Inner is underflowing and hene btree.fix_merge must
                // have been set.


                // case: the inner node is the root and has just one child.
                // that child becomes the new root
                if (leftinner == NULL && rightinner == NULL)
                {
                    BTREE_ASSERT(currentId == m_rootId);
                    BTREE_ASSERT(inner->slotuse == 0);

                    // need to rewrite the child to now have NodeId = m_rootId0
                    // delete the older version and delete inner as well

                    // first lookup in the cache to see if this child was
                    // recently modified. If not, read from the log.
                    // This order is important
                    Buffer buffer;
                    const void* newRoot = NULL;

                    std::map<NodeId, uint32_t>::iterator it =
                                    cache.find(inner->childid[0]);


                    if (inner->level == 1) {
                        if (it != cache.end())
                            newRoot = reinterpret_cast<const leaf_node*>(
                                        logBuffer.getRange(it->second,
                                        sizeof(leaf_node)));
                        else
                            newRoot = static_cast<const leaf_node*>(
                                        getPointerToObject(inner->childid[0],
                                                           &buffer));
                        // it's child is a leaf
                        writeNode(newRoot, sizeof(leaf_node), m_rootId, false);
                        free_node(inner->childid[0]);
                        updateLeafCount();
                    } else {
                        if (it != cache.end())
                            newRoot = reinterpret_cast<const inner_node*>(
                                        logBuffer.getRange(it->second,
                                        sizeof(inner_node)));
                        else
                            newRoot = static_cast<const leaf_node*>(
                                        getPointerToObject(inner->childid[0],
                                                           &buffer));
                        writeNode(newRoot, sizeof(inner_node), m_rootId, false);
                        free_node(inner->childid[0]);
                        updateInnerCount();
                    }

                    return btree_ok;
                }
                else
                {
                    // create a mutable copy of inner if not already created
                    if (newInnerInfo.data == NULL)
                    {
                        createMutableInner(constInner, &newInnerInfo);
                        inner = static_cast<inner_node *>(newInnerInfo.data);
                        innerDirty = true;
                    }
                    // create a mutable copy of parent if not already created 
                    if (newParentInfo->data == NULL)
                    {
                        createMutableInner(parent, newParentInfo);
                        // newParent is mutable
                        newParent = static_cast<inner_node *>(newParentInfo->data);
                        parentDirty = true;
                    }
                    // case : if both left and right leaves would underflow in case of
                    // a shift, then merging is necessary. choose the more local merger
                    // with our parent
                    if ( (leftinner == NULL || leftinner->isfew()) && (rightinner == NULL || rightinner->isfew()) )
                    {
                        if (leftparent == parent) {
                            myres |= merge_inner(leftinner, *left, inner, newParent, parentslot - 1);
                        }
                        else {
                            myres |= merge_inner(inner, currentId, rightinner, newParent, parentslot);
                            myres |= btree_right_merge;
                        }
                    }
                    // case : the right leaf has extra data, so balance right with current
                    else if ( (leftinner != NULL && leftinner->isfew()) && (rightinner != NULL && !rightinner->isfew()) )
                    {
                        if (rightparent == parent)
                            shift_left_inner(inner, currentId, rightinner, *right, newParent, parentslot);
                        else
                            myres |= merge_inner(leftinner, *left, inner, newParent, parentslot - 1);
                    }
                    // case : the left leaf has extra data, so balance left with current
                    else if ( (leftinner != NULL && !leftinner->isfew()) && (rightinner != NULL && rightinner->isfew()) )
                    {
                        if (leftparent == parent) {
                            shift_right_inner(leftinner, *left, inner, currentId, newParent, parentslot - 1);
                        }
                        else {
                            myres |= merge_inner(inner, currentId, rightinner, newParent, parentslot);
                            myres |= btree_right_merge;
                        }
                    }
                    // case : both the leaf and right leaves have extra data and our
                    // parent, choose the leaf with more data
                    else if (leftparent == rightparent)
                    {
                        if (leftinner->slotuse <= rightinner->slotuse)
                            shift_left_inner(inner, currentId, rightinner, *right, newParent, parentslot);
                        else
                            shift_right_inner(leftinner, *left, inner, currentId, newParent, parentslot - 1);
                    }
                    else
                    {
                        if (leftparent == parent)
                            shift_right_inner(leftinner, *left, inner, currentId, newParent, parentslot - 1);
                        else
                            shift_left_inner(inner, currentId, rightinner, *right, newParent, parentslot);
                    }
                }
            }

            // no underflow
            else
            {
                // Have to write inner out in this case
                // Note that if parent is dirty, inner is also necessarily dirty
                if (innerDirty)
                {
                    if (!myres.has(btree_not_found) &&
                        !myres.has(btree_update_lastkey) &&
                        !myres.has(btree_fixmerge) && !parentDirty)
                    {
                        // reuse the nodeId in this case
                        writeNode(inner, sizeof(inner_node), currentId, false);
                        // this to inform the parent that it was not modified by
                        // the child
                        if (newParentInfo)
                            newParentInfo->data = NULL;
                    }
                    else
                    {
                        if (parent) {
                            newParent->childid[parentslot] =
                                                writeNode(inner,
                                                          sizeof(inner_node),
                                                          currentId, false);
                        }
                        else
                            // inner is the root node. It still tries to forward
                            // update_lastkey up but it is of no use. The root
                            // has been modified appropriately. Rewrite root
                            // object using same nodeId
                            writeNode(inner, sizeof(inner_node), m_rootId, false);
                    }
                }
            }

            return myres;
        }
    }

    /// Merge two leaf nodes. The function moves all key/data pairs from right
    /// to left and sets right's slotuse to zero. The right slot is then
    /// removed by the calling parent node. The callers make sure that all
    /// arguments are mutable pointers.
    result_t merge_leaves(leaf_node* left, NodeId leftNodeId, leaf_node* right,
                          inner_node* parent, unsigned int parentslot)
    {
        // left corresponds to parent->childid[slot] and right corresponds
        // to parent->childid[slot] + 1
        BTREE_PRINT("Merge leaf nodes " << left << " and " << right << " with common parent " << parent << ".");
        (void)parent;

        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->slotuse + right->slotuse < leafslotmax);

        // Need to write new variant of left node object here.
        std::copy(right->slotkey, right->slotkey + right->slotuse,
                  left->slotkey + left->slotuse);
        data_copy(right->slotdata, right->slotdata + right->slotuse,
                  left->slotdata + left->slotuse);

        left->slotuse += right->slotuse;

        // adjust the nextleaf and the prevleaf nodeId values for the
        // relevant nodes
        left->nextleaf = right->nextleaf;
        if (left->nextleaf != INVALID_NODEID) {

            Buffer buffer;
            const leaf_node *constNextLeaf = static_cast<const leaf_node*>(
                                        getPointerToObject(left->nextleaf,
                                                           &buffer));
            NodeObjectInfo nextLeafInfo;
            createMutableLeaf(constNextLeaf, &nextLeafInfo);
            leaf_node *nextLeaf = static_cast<leaf_node*>(nextLeafInfo.data);
            nextLeaf->prevleaf = leftNodeId;
            // rewrite nextLeaf with same NodeId
            writeNode(nextLeaf, sizeof(leaf_node), left->nextleaf, false);
        }


        // need not unnecessarily delete or write this object out again here.
        // the comments above mention that this object will be removed
        // by the calling parent
        right->slotuse = 0;

        parent->childid[parentslot] = writeNode(left, sizeof(leaf_node),
                                                leftNodeId, false);

        // newParentInfo is not passed as an argument because
        // the below statement is not required because this was done before
        // calling this function. This is left as commented code here to
        // give some indication to what is happening.
        // newParentInfo->data = parent;

        return btree_fixmerge;
    }

    /// Merge two inner nodes. The function moves all key/childid pairs from
    /// right to left and sets right's slotuse to zero. The right slot is then
    /// removed by the calling parent node.
    result_t merge_inner(inner_node* left, NodeId leftNodeId, inner_node* right,
                         inner_node* parent, unsigned int parentslot)
    {
        BTREE_PRINT("Merge inner nodes " << left << " and " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(parent->childid[parentslot] == leftNodeId);

        BTREE_ASSERT(left->slotuse + right->slotuse < innerslotmax);

        // Need to write out a new variant of left object. The right node
        // as mentioned above will be removed by the calling parent.

        // retrieve the decision key from parent
        left->slotkey[left->slotuse] = parent->slotkey[parentslot];
        left->slotuse++;

        // copy over keys and children from right
        std::copy(right->slotkey, right->slotkey + right->slotuse,
                  left->slotkey + left->slotuse);
        std::copy(right->childid, right->childid + right->slotuse+1,
                  left->childid + left->slotuse);

        left->slotuse += right->slotuse;
        right->slotuse = 0;

        parent->childid[parentslot] = writeNode(left, sizeof(inner_node),
                                                leftNodeId, false);

        // newParentInfo is not passed as an argument because
        // the below statement is not required because this was done before
        // calling this function. This is commented here to give some
        // indication to what is happening.
        // newParentInfo->data = parent;

        return btree_fixmerge;
    }

    /// Balance two leaf nodes. The function moves key/data pairs from right to
    /// left so that both nodes are equally filled. The parent node is updated
    /// if possible.
    result_t shift_left_leaf(leaf_node *left, NodeId leftNodeId,
                             leaf_node *right, NodeId rightNodeId,
                             inner_node *parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->slotuse < right->slotuse);

        unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->slotuse + shiftnum < leafslotmax);

        // copy the first items from the right node to the last slot in the left node.

        std::copy(right->slotkey, right->slotkey + shiftnum,
                  left->slotkey + left->slotuse);
        data_copy(right->slotdata, right->slotdata + shiftnum,
                  left->slotdata + left->slotuse);

        left->slotuse += shiftnum;

        // shift all slots in the right node to the left

        std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
                  right->slotkey);
        data_copy(right->slotdata + shiftnum, right->slotdata + right->slotuse,
                  right->slotdata);

        right->slotuse -= shiftnum;

        parent->childid[parentslot] = writeNode(left, sizeof(leaf_node),
                                                leftNodeId, false);
        parent->childid[parentslot + 1] = writeNode(right, sizeof(leaf_node),
                                                    rightNodeId, false);

        // fixup parent
        if (parentslot < parent->slotuse) {
            parent->slotkey[parentslot] = left->slotkey[left->slotuse - 1];
            return btree_ok;
        }
        else { // the update is further up the tree
            return result_t(btree_update_lastkey, left->slotkey[left->slotuse - 1]);
        }
    }

    /// Balance two inner nodes. The function moves key/data pairs from right
    /// to left so that both nodes are equally filled. The parent node is
    /// updated if possible.
    void shift_left_inner(inner_node *left, NodeId leftNodeId,
                          inner_node *right, NodeId rightNodeId,
                          inner_node *parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(left->slotuse < right->slotuse);
        BTREE_ASSERT(parent->childid[parentslot] == leftNodeId);

        unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;

        BTREE_PRINT("Shifting (inner) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");

        BTREE_ASSERT(left->slotuse + shiftnum < innerslotmax);

        // copy the parent's decision slotkey and childid to the first new key on the left
        left->slotkey[left->slotuse] = parent->slotkey[parentslot];
        left->slotuse++;

        // copy the other items from the right node to the last slots in the left node.

        std::copy(right->slotkey, right->slotkey + shiftnum-1,
                  left->slotkey + left->slotuse);
        std::copy(right->childid, right->childid + shiftnum,
                  left->childid + left->slotuse);

        left->slotuse += shiftnum - 1;

        // fixup parent
        parent->slotkey[parentslot] = right->slotkey[shiftnum - 1];

        // shift all slots in the right node

        std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
                  right->slotkey);
        std::copy(right->childid + shiftnum, right->childid + right->slotuse+1,
                  right->childid);

        right->slotuse -= shiftnum;

        parent->childid[parentslot] = writeNode(left, sizeof(inner_node),
                                                leftNodeId, false);
        parent->childid[parentslot + 1] = writeNode(right, sizeof(inner_node),
                                                    rightNodeId, false);
    }

    /// Balance two leaf nodes. The function moves key/data pairs from left to
    /// right so that both nodes are equally filled. The parent node is updated
    /// if possible.
    void shift_right_leaf(leaf_node *left, NodeId leftNodeId,
                          leaf_node *right, NodeId rightNodeId,
                          inner_node *parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->isleafnode() && right->isleafnode());
        BTREE_ASSERT(parent->level == 1);

        BTREE_ASSERT(left->slotuse > right->slotuse);

        unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");

        // shift all slots in the right node

        BTREE_ASSERT(right->slotuse + shiftnum < leafslotmax);

        std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
                           right->slotkey + right->slotuse + shiftnum);
        data_copy_backward(right->slotdata, right->slotdata + right->slotuse,
                           right->slotdata + right->slotuse + shiftnum);

        right->slotuse += shiftnum;

        // copy the last items from the left node to the first slot in the right node.
        std::copy(left->slotkey + left->slotuse - shiftnum, left->slotkey + left->slotuse,
                  right->slotkey);
        data_copy(left->slotdata + left->slotuse - shiftnum, left->slotdata + left->slotuse,
                  right->slotdata);

        left->slotuse -= shiftnum;

        parent->childid[parentslot] = writeNode(left, sizeof(leaf_node),
                                                leftNodeId, false);
        parent->childid[parentslot + 1] = writeNode(right, sizeof(leaf_node),
                                                    rightNodeId, false);

        parent->slotkey[parentslot] = left->slotkey[left->slotuse-1];
    }

    /// Balance two inner nodes. The function moves key/data pairs from left to
    /// right so that both nodes are equally filled. The parent node is updated
    /// if possible.
    void shift_right_inner(inner_node *left, NodeId leftNodeId,
                          inner_node *right, NodeId rightNodeId,
                          inner_node *parent, unsigned int parentslot)
    {
        BTREE_ASSERT(left->level == right->level);
        BTREE_ASSERT(parent->level == left->level + 1);

        BTREE_ASSERT(left->slotuse > right->slotuse);
        BTREE_ASSERT(parent->childid[parentslot] == leftNodeId);

        unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

        BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");

        // shift all slots in the right node

        BTREE_ASSERT(right->slotuse + shiftnum < innerslotmax);

        std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
                           right->slotkey + right->slotuse + shiftnum);
        std::copy_backward(right->childid, right->childid + right->slotuse+1,
                           right->childid + right->slotuse+1 + shiftnum);

        right->slotuse += shiftnum;

        // copy the parent's decision slotkey and childid to the last new key on the right
        right->slotkey[shiftnum - 1] = parent->slotkey[parentslot];

        // copy the remaining last items from the left node to the first slot in the right node.
        std::copy(left->slotkey + left->slotuse - shiftnum+1, left->slotkey + left->slotuse,
                  right->slotkey);
        std::copy(left->childid + left->slotuse - shiftnum+1, left->childid + left->slotuse+1,
                  right->childid);

        // copy the first to-be-removed key from the left node to the parent's decision slot
        parent->slotkey[parentslot] = left->slotkey[left->slotuse - shiftnum];

        left->slotuse -= shiftnum;

        parent->childid[parentslot] = writeNode(left, sizeof(inner_node),
                                                leftNodeId, false);
        parent->childid[parentslot + 1] = writeNode(right, sizeof(inner_node),
                                                    rightNodeId, false);
    }

private:
    /* Debug functions to print inner and leaf nodes */

    void printInnerNodeKeys(const inner_node *innernode) const
    {
        RAMCLOUD_LOG(DEBUG, "Printing inner node keys");
        for (unsigned short slot = 0; slot < innernode->slotuse; ++slot)
        {
            RAMCLOUD_LOG(DEBUG,
                         " ( %s ) ", std::string((const char *)&innernode->slotkey[slot], 40).c_str());
        }
    }

    void printInnerNode(const inner_node *innernode) const
    {
        RAMCLOUD_LOG(DEBUG, "Printing inner node");
        for (unsigned short slot = 0; slot < innernode->slotuse; ++slot)
        {
            RAMCLOUD_LOG(DEBUG,
                         " ( %lu ) %s ", innernode->childid[slot],
                         std::string((const char *)&innernode->slotkey[slot], 40).c_str());
        }
        RAMCLOUD_LOG(DEBUG, "( %lu )", innernode->childid[innernode->slotuse]);
    }

    void printLeafNode(const leaf_node *leafnode) const
    {
        RAMCLOUD_LOG(DEBUG, "Printing leaf node");
        RAMCLOUD_LOG(DEBUG, "%lu <- -> %lu", leafnode->prevleaf, leafnode->nextleaf);
        for (unsigned short slot = 0; slot < leafnode->slotuse; ++slot)
        {
            RAMCLOUD_LOG(ERROR,
                         " %s ", std::string((const char *)&leafnode->slotkey[slot], 40).c_str());
        }
    }

public:
    // *** Verification of B+ Tree Invariants

    /// Run a thorough verification of all B+ tree invariants. The program
    /// aborts via assert() if something is wrong.
    void verify() const
    {
        key_type minkey, maxkey;
        tree_stats vstats;

        if (nextNodeId > ROOT_ID)
        {
            verify_node(m_rootId, &minkey, &maxkey, vstats);

            assert( vstats.itemcount == m_stats.itemcount );
            assert( vstats.leaves == m_stats.leaves );
            assert( vstats.innernodes == m_stats.innernodes );

            // verify_leaflinks won't work. if this
            // is not required, remove it.
            //verify_leaflinks();
        }
    }

private:

    /// Recursively descend down the tree and verify each node
    void verify_node(NodeId nodeId, key_type* minkey, key_type* maxkey, tree_stats &vstats) const
    {
        Buffer buffer;
        const node* n = static_cast<const node *>(getPointerToObject(nodeId, &buffer));
        BTREE_PRINT("verifynode " << n);

        if (n->isleafnode())
        {
            const leaf_node *leaf = static_cast<const leaf_node*>(n);

            assert( nodeId == m_rootId || !leaf->isunderflow() );
            assert( leaf->slotuse > 0 );

            for(unsigned short slot = 0; slot < leaf->slotuse - 1; ++slot)
            {
                assert(key_lessequal(leaf->slotkey[slot], leaf->slotkey[slot + 1]));
            }

            *minkey = leaf->slotkey[0];
            *maxkey = leaf->slotkey[leaf->slotuse - 1];

            vstats.leaves++;
            vstats.itemcount += leaf->slotuse;
        }
        else // !n->isleafnode()
        {
            const inner_node *inner = static_cast<const inner_node*>(n);
            vstats.innernodes++;

            assert( nodeId == m_rootId || !inner->isunderflow() );
            assert( inner->slotuse > 0 );

            for(unsigned short slot = 0; slot < inner->slotuse - 1; ++slot)
            {
                assert(key_lessequal(inner->slotkey[slot], inner->slotkey[slot + 1]));
            }

            for(unsigned short slot = 0; slot <= inner->slotuse; ++slot)
            {
                Buffer subnodeBuffer;
                NodeId subnodeId = inner->childid[slot];
                const node* subnode = static_cast<const node*>(
                                            getPointerToObject(
                                            subnodeId,
                                            &subnodeBuffer));
                key_type subminkey = key_type();
                key_type submaxkey = key_type();

                assert(subnode->level + 1 == inner->level);
                verify_node(subnodeId, &subminkey, &submaxkey, vstats);

                BTREE_PRINT("verify subnode " << subnode << ": " << subminkey << " - " << submaxkey);

                if (slot == 0)
                    *minkey = subminkey;
                else
                    assert(key_greaterequal(subminkey, inner->slotkey[slot-1]));

                if (slot == inner->slotuse)
                    *maxkey = submaxkey;
                else
                    assert(key_equal(inner->slotkey[slot], submaxkey));

                if (inner->level == 1 && slot < inner->slotuse)
                {
                    // children are leaves and must be linked together in the
                    // correct order
                    Buffer firstBuffer, secondBuffer;
                    const leaf_node *leafa = static_cast<const leaf_node*>(
                                                    getPointerToObject(
                                                    inner->childid[slot], &firstBuffer));
                    const leaf_node *leafb = static_cast<const leaf_node*>(
                                                    getPointerToObject(
                                                    inner->childid[slot + 1], &secondBuffer));

                    (void)leafa; (void)leafb;
                }
                if (inner->level == 2 && slot < inner->slotuse)
                {
                    // verify leaf links between the adjacent inner nodes
                    Buffer firstBuffer, secondBuffer, thirdBuffer, fourthBuffer;
                    const inner_node* parenta = static_cast<const inner_node*>(
                                                    getPointerToObject(
                                                    inner->childid[slot], &firstBuffer));
                    const inner_node *parentb = static_cast<const inner_node*>(
                                                    getPointerToObject(
                                                    inner->childid[slot + 1], &secondBuffer));

                    const leaf_node *leafa = static_cast<const leaf_node*>(
                                                    getPointerToObject(
                                                    parenta->childid[parenta->slotuse], &thirdBuffer));
                    const leaf_node *leafb = static_cast<const leaf_node*>(
                                                    getPointerToObject(
                                                    parentb->childid[0], &fourthBuffer));

                    (void)leafa; (void)leafb;
                }
            }
        }
    }

    /// Verify the double linked list of leaves.
    void verify_leaflinks() const
    {
        // empty tree
        if (nextNodeId <= ROOT_ID)
            return;

        //NodeId nodeId = m_headleaf;
        NodeId nodeId;
        Buffer buffer;
        const leaf_node *n = static_cast<const leaf_node *>(
                                getPointerToObject(nodeId,
                                &buffer));

        assert(n->level == 0);
        //assert(!n || n->prevleaf == NULL);

        unsigned int testcount = 0;

        while(n)
        {
            assert(n->level == 0);
            assert(n->slotuse > 0);

            for(unsigned short slot = 0; slot < n->slotuse - 1; ++slot)
            {
                assert(key_lessequal(n->slotkey[slot], n->slotkey[slot + 1]));
            }

            testcount += n->slotuse;

            if (n->nextleaf)
            {
                assert(key_lessequal(n->slotkey[n->slotuse-1], n->nextleaf->slotkey[0]));

                assert(n == n->nextleaf->prevleaf);
            }
            else
            {
                //assert(m_tailleaf == n);
            }

            n = n->nextleaf;
        }

        assert(testcount == size());
    }
};

} // namespace str

} // namespace RAMCloud

#endif // _STR_BTREE_H_
